{
	"id": 29414838,
	"key": "Rust_(programming_language)",
	"title": "Rust (programming language)",
	"latest": {
		"id": 1318205510,
		"timestamp": "2025-10-22T14:47:24Z"
	},
	"content_model": "wikitext",
	"license": {
		"url": "https://creativecommons.org/licenses/by-sa/4.0/deed.en",
		"title": "Creative Commons Attribution-Share Alike 4.0"
	},
	"source": "{{Short description|General-purpose programming language}}\n{{Good article}}\n{{Use American English|date=July 2022}}\n{{Use mdy dates|date=July 2022|cs1-dates=y}}\n{{Infobox programming language\n| name = Rust\n| logo = Rust programming language black logo.svg{{!}}class=skin-invert\n| logo size = 150px\n| logo alt = Rust logo; a capital letter R set into a sprocket\n| paradigms = {{cslist|\n  [[Concurrent computing|Concurrent]]|\n  [[Functional programming|functional]]|\n  [[Generic programming|generic]]|\n  [[Imperative programming|imperative]]|\n  [[Structured programming|structured]]|\n}}\n| released = {{Start date and age|2012|01|19}}\n| developer = The Rust Team\n| latest release version = {{wikidata|property|edit|reference|P548=Q2804309|P348}}\n| latest release date = {{start date and age|{{wikidata|qualifier|mdy|P548=Q2804309|P348|P577}}}}\n| typing = {{cslist|\n  [[Affine type system|Affine]]|\n  [[Type inference|inferred]]|\n  [[Nominal type system|nominal]]|\n  [[Static typing|static]]|\n  [[Strong and weak typing|strong]]|\n}}\n| programming language = [[OCaml]] (2006–2011)<br/>Rust (2012–present)\n| platform = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including build tools, host tools, and standard library support for [[x86-64]], [[ARM architecture family|ARM]], [[MIPS architecture|MIPS]], [[RISC-V]], [[WebAssembly]], [[P6 (microarchitecture)|i686]], [[AArch64]], [[PowerPC]], and [[Linux on IBM Z|s390x]].<ref name=CrossPlatform>{{Cite web |title=Platform Support |website=The rustc book |url=https://doc.rust-lang.org/rustc/platform-support.html |access-date=2022-06-27 |archive-date=2022-06-30  |archive-url=https://web.archive.org/web/20220630164523/https://doc.rust-lang.org/rustc/platform-support.html |url-status=live }}</ref>}}\n| operating system = [[Cross-platform software|Cross-platform]]{{refn|group=note|Including [[Windows]], [[Linux]], [[macOS]], [[FreeBSD]], [[NetBSD]], and [[Illumos]]. Host build tools on [[Android (operating system)|Android]], [[iOS]], [[Haiku (operating system)|Haiku]], [[Redox (operating system)|Redox]], and [[Fuchsia (operating system)|Fuchsia]] are not officially shipped; these operating systems are supported as targets.<ref name=\"CrossPlatform\" />}}\n| license = [[MIT License|MIT]], [[Apache License|Apache 2.0]]{{refn|group=note|Third-party dependencies, e.g., [[LLVM]] or [[MSVC]], are subject to their own licenses.<ref>{{cite web |title=Copyright |url=https://github.com/rust-lang/rust/blob/master/COPYRIGHT |website=[[GitHub]] |publisher=The Rust Programming Language |date=19 October 2022 |access-date=2022-10-19  |archive-date=2023-07-22  |archive-url=https://web.archive.org/web/20230722190056/http://github.com/rust-lang/rust/blob/master/COPYRIGHT |url-status=live }}</ref><ref name=\"licenses\" />}}\n| file ext = <code>.rs</code>, <code>.rlib</code>\n| website = {{url|https://www.rust-lang.org/|rust-lang.org}}\n| influenced by = {{cslist|\n  [[Alef (programming language)|Alef]]|\n  [[BETA (programming language)|BETA]]|\n  [[CLU (programming language)|CLU]]|\n  [[C Sharp (programming language)|C#]]|\n  [[C++]]|\n  [[Cyclone (programming language)|Cyclone]]|\n  [[Elm (programming language)|Elm]]|\n  [[Erlang (programming language)|Erlang]]|\n  [[Haskell]]|\n  [[Hermes (programming language)|Hermes]]|\n  [[Limbo (programming language)|Limbo]]|\n  [[Mesa (programming language)|Mesa]]|\n  [[Napier88|Napier]]|\n  [[Newsqueak]]|\n  [[Typestate analysis|NIL]]{{refn|group=note|name=nil|NIL is cited as an influence for Rust in multiple sources; this likely refers to Network Implementation Language developed by Robert Strom and others at [[IBM]], which pioneered [[typestate analysis]],<ref name=\"Strom1983\">{{cite book|last1=Strom|first1=Robert E.|title=Proceedings of the 10th ACM SIGACT-SIGPLAN symposium on Principles of programming languages - POPL '83|year=1983|pages=276–284|doi=10.1145/567067.567093|chapter=Mechanisms for compile-time enforcement of security|isbn=0897910907|s2cid=6630704 }}</ref><ref>{{cite journal|last=Strom|first=Robert E.|author2=Yemini, Shaula |title=Typestate: A programming language concept for enhancing software reliability|journal=IEEE Transactions on Software Engineering|year=1986|volume=12|pages=157–171|publisher=IEEE |url=https://www.cs.cmu.edu/~aldrich/papers/classic/tse12-typestate.pdf|doi=10.1109/tse.1986.6312929|s2cid=15575346 }}</ref> not to be confused with [[NIL (programming language)|New Implementation of LISP]].}}|\n  [[OCaml]]|\n  [[Ruby (programming language)|Ruby]]|\n  [[Sather]]|\n  [[Scheme (programming language)|Scheme]]|\n  [[Standard ML]]|\n  [[Swift (programming language)|Swift]]<ref>{{Cite web |title=Uniqueness Types |url=https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html |access-date=2016-10-08 |website=Rust Blog |quote=\"Those of you familiar with the Elm style may recognize that the updated {{mono|--explain}} messages draw heavy inspiration from the Elm approach.\" |archive-date=2016-09-15  |archive-url=https://web.archive.org/web/20160915133745/https://blog.rust-lang.org/2016/08/10/Shape-of-errors-to-come.html |url-status=live }}</ref><ref name=\"influences\" />\n}}\n| influenced = {{cslist|\n  [[Idris (programming language)|Idris]]<ref>{{Cite web |title=Uniqueness Types |url=http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html |access-date=2022-07-14 |website=Idris 1.3.3 documentation |quote=\"They are inspired by ... ownership types and borrowed pointers in the Rust programming language.\" |archive-date=2018-11-21  |archive-url=https://web.archive.org/web/20181121072557/http://docs.idris-lang.org/en/latest/reference/uniqueness-types.html |url-status=live }}</ref>|\n  <!-- The article was deleted -- can be reinstated in the future if the article topic is deemed notable\n  [[Mojo (programming language)|Mojo]]<ref>{{Cite web |last=Claburn |first=Thomas |title=Modular reveals Mojo, Python superset with C-level speed |url=https://www.theregister.com/2023/05/05/modular_struts_its_mojo_a/ |access-date=2023-05-13 |website=The Register |language=en}}</ref>|\n  -->\n  [[Project Verona]]<ref name=\"Project Verona\" />|\n  [[SPARK (programming language)|SPARK]]<ref name=\"Jaloyan\" />|\n  [[Swift (programming language)|Swift]]<ref name=\"Lattner\" />|\n  [[V (programming language)|V]]<ref>{{Cite web |title=V documentation (Introduction) |url=https://github.com/vlang/v/blob/master/doc/docs.md#introduction |access-date=2023-11-04 |website=[[GitHub]] |publisher=The V Programming Language |language=en}}</ref>|\n  [[Zig (programming language)|Zig]]<ref>{{Cite web |last=Yegulalp |first=Serdar |date=2016-08-29 |title=New challenger joins Rust to topple C language |url=https://www.infoworld.com/article/3113083/new-challenger-joins-rust-to-upend-c-language.html |access-date=2022-10-19 |website=[[InfoWorld]] |language=en |archive-date=2021-11-25  |archive-url=https://web.archive.org/web/20211125104022/https://www.infoworld.com/article/3113083/new-challenger-joins-rust-to-upend-c-language.html |url-status=live }}</ref>|\n}}\n}}\n\n'''Rust''' is a [[General-purpose programming language|general-purpose]] [[programming language]]. It is noted for its emphasis on [[Computer performance|performance]], [[type safety]], [[Concurrency (computer science)|concurrency]], and [[memory safety]].\n\nRust supports multiple [[programming paradigm]]s. It was influenced by ideas from [[functional programming]], including [[Immutable object|immutability]], [[higher-order function]]s, [[algebraic data type]]s, and [[pattern matching]]. It also supports [[object-oriented programming]] via structs, [[Union type|enums]], traits, and methods. Rust is noted for enforcing memory safety (i.e., that all [[Reference (computer science)|references]] point to valid memory) without a conventional [[Garbage collection (computer science)|garbage collector]]; instead, memory safety errors and [[data race]]s are prevented by the \"borrow checker\", which tracks the [[object lifetime]] of references [[Compiler|at compile time]].\n\nSoftware developer Graydon Hoare created Rust in 2006 while working at [[Mozilla]], which officially sponsored the project in 2009. The first stable release, Rust 1.0, was published in May 2015. Following a layoff of Mozilla employees in August 2020, four other companies joined Mozilla in sponsoring Rust through the creation of the [[#Rust Foundation|Rust Foundation]] in February 2021.\n\nRust has been adopted by many software projects, especially [[web service]]s and [[system software]], and is the first language other than [[C (programming language)|C]] and [[Assembly language|assembly]] to be supported in the development of the [[Linux kernel]]. It has been studied academically and has a growing community of developers.\n\n== History ==\n=== 2006–2009: Early years  ===\n[[File:MozillaCaliforniaHeadquarters.JPG|thumb|right|Mozilla Foundation headquarters, 650 Castro Street in [[Mountain View, California]], June 2009]]\nRust began as a personal project by [[Mozilla]] employee Graydon Hoare in 2006, who started the project due to his frustration with a broken elevator in his apartment building.<ref name=\"MITTechReview\">{{cite web |url=https://www.technologyreview.com/2023/02/14/1067869/rust-worlds-fastest-growing-programming-language/ |title=How Rust went from a side project to the world's most-loved programming language |last=Thompson |first=Clive |date=2023-02-14 |website=MIT Technology Review |language=en |access-date=2023-02-23 |archive-date=2024-09-19  |archive-url=https://web.archive.org/web/20240919102849/https://www.technologyreview.com/2023/02/14/1067869/rust-worlds-fastest-growing-programming-language/ |url-status=live }}</ref> Hoare named Rust after the [[Rust (fungus)|group of fungi]] that is \"over-engineered for survival\".<ref name=\"MITTechReview\"/> During the time period between 2006 and 2009, Rust was not publicized to others at Mozilla and was written in Hoare's free time;<ref name=Klabnik2016ACMHistory>{{Cite book |last=Klabnik |first=Steve |chapter=The History of Rust |date=2016-06-02 |title=Applicative 2016 |chapter-url=https://dl.acm.org/doi/10.1145/2959689.2960081 |page=80 |location=New York, NY, USA |publisher=Association for Computing Machinery |doi=10.1145/2959689.2960081 |isbn=978-1-4503-4464-7}}</ref>{{rp|at=7:50}} Hoare began speaking about the language around 2009 after a small group at Mozilla became interested in the project.<ref name=Hoare2010>{{Cite conference |url=http://venge.net/graydon/talks/intro-talk-2.pdf |archive-url=https://archive.today/20211226213836/http://venge.net/graydon/talks/intro-talk-2.pdf |archive-date=2021-12-26 |last=Hoare |first=Graydon |title=Project Servo: Technology from the past come to save the future from itself |publisher=Mozilla Annual Summit |date=July 2010 |access-date=2024-10-29 }}</ref> Hoare cited languages from the 1970s, 1980s, and 1990s as influences — including [[CLU (programming language)|CLU]], [[BETA (programming language)|BETA]], [[Mesa (programming language)|Mesa]], NIL,{{refn|group=note|name=nil}} [[Erlang (programming language)|Erlang]], [[Newsqueak]], [[Napier88|Napier]], [[Hermes (programming language)|Hermes]], [[Sather]], [[Alef (programming language)|Alef]], and [[Limbo (programming language)|Limbo]].<ref name=Hoare2010/> He described the language as \"technology from the past come to save the future from itself.\"<ref name=Klabnik2016ACMHistory/>{{rp|at=8:17}}<ref name=Hoare2010/> Early Rust developer Manish Goregaokar similarly described Rust as being based on \"mostly decades-old research.\"<ref name=\"MITTechReview\"/>\n\nDuring the early years, the Rust [[compiler]] was written in about 38,000 lines of [[OCaml]].<ref name=Klabnik2016ACMHistory/>{{rp|at=15:34}}<ref name=OCamlCompiler>{{Cite web |last=Hoare |first=Graydon |title=Rust Prehistory (Archive of the original Rust OCaml compiler source code) |website=[[GitHub]] |date=November 2016 |url=https://github.com/graydon/rust-prehistory/tree/master |access-date=2024-10-29 }}</ref> Features of early Rust that were later removed include explicit [[object-oriented programming]] via an {{code|obj}} keyword,<ref name=Klabnik2016ACMHistory/>{{rp|at=10:08}} and a [[typestate analysis|typestates]] system that would allow variables of a type to be tracked along with state changes (such as going from uninitialized to initialized).<ref name=Klabnik2016ACMHistory/>{{rp|at=13:12}}\n\n=== 2009–2012: Mozilla sponsorship ===\nMozilla officially sponsored the Rust project in 2009.<ref name=\"MITTechReview\"/> [[Brendan Eich]] and other executives, intrigued by the possibility of using Rust for a safe [[web browser]] [[browser engine|engine]], placed engineers on the project including Patrick Walton, Niko Matsakis, Felix Klock, and Manish Goregaokar.<ref name=\"MITTechReview\"/> A conference room taken by the project developers was dubbed \"the nerd cave,\" with a sign placed outside the door.<ref name=\"MITTechReview\"/>\n\nDuring this time period, work had shifted from the initial OCaml compiler to a [[Self-hosting (compilers)|self-hosting compiler]], ''i.e.'', written in Rust, based on [[LLVM]].<ref name=Rust0.1>{{Cite web |title=0.1 first supported public release Milestone · rust-lang/rust |url=https://github.com/rust-lang/rust/milestone/3?closed=1 |access-date=2024-10-29 |website=[[GitHub]] |language=en}}</ref>{{refn|group=note|The list of Rust compiler versions (referred to as a bootstrapping chain) has history going back to 2012.<ref name=Nelson2022RustConf>{{Cite AV media |url=https://www.youtube.com/watch?v=oUIjG-y4zaA |last=Nelson |first=Jynn |title=RustConf 2022 - Bootstrapping: The once and future compiler |publisher=Rust Team |date=2022-08-05 |access-date=2024-10-29 |location=Portland, Oregon |via=YouTube}}</ref>}} The Rust ownership system was also in place by 2010.<ref name=\"MITTechReview\"/> \n\nThe first public release, Rust 0.1, was released on January 20, 2012<ref name=Rust0.1a>{{Cite mailing list |last=Anderson |first=Brian |date=2012-01-24 |title=[rust-dev] The Rust compiler 0.1 is unleashed |url=https://mail.mozilla.org/pipermail/rust-dev/2012-January/001256.html |mailing-list=rust-dev |access-date=2025-01-07 |archive-url=https://web.archive.org/web/20120124160628/https://mail.mozilla.org/pipermail/rust-dev/2012-January/001256.html |archive-date=January 24, 2012 }}</ref> for Windows, Linux, and MacOS.<ref name=ExtremeTechRust0.1>{{Cite web |last=Anthony |first=Sebastian |date=2012-01-24 |title=Mozilla releases Rust 0.1, the language that will eventually usurp Firefox's C++ |url=https://www.extremetech.com/internet/115207-mozilla-releases-rust-0-1-the-language-that-will-eventually-usurp-firefoxs-c |access-date=2025-01-07 |website=ExtremeTech |language=en}}</ref> The early 2010s saw increasing involvement from open source volunteers outside of Mozilla and outside of the United States. At Mozilla, executives would eventually employ over a dozen engineers to work on Rust full time over the next decade.<ref name=\"MITTechReview\"/> The Rust logo was developed in 2011 based on a bicycle chainring.<ref>{{cite web |title=Rust logo |url=https://bugzilla.mozilla.org/show_bug.cgi?id=680521 |website=[[Bugzilla]] |access-date=2 February 2024 |archive-date=2024-02-02  |archive-url=https://web.archive.org/web/20240202045212/https://bugzilla.mozilla.org/show_bug.cgi?id=680521 |url-status=live }}</ref>\n\n=== 2012–2015: Evolution ===\n\nThe years from 2012 to 2015 were marked by substantial changes to the Rust [[type system]], including the removal of the typestate system and [[Garbage collection (computer science)|garbage collector]].<ref name=Klabnik2016ACMHistory/>{{rp|at=18:36}}<ref name=\"MITTechReview\"/> Memory management through the ownership system was gradually consolidated and expanded to prevent memory-related bugs. By 2013, the garbage collector feature was rarely used, and was removed by the team in favor of the ownership system.<ref name=\"MITTechReview\"/> Other changes during this time included the removal of [[pure function]]s, which were declared by an explicit {{code|pure}} annotation, in March 2013.<ref>{{Cite web |title=Purity by pcwalton · Pull Request #5412 · rust-lang/rust |url=https://github.com/rust-lang/rust/pull/5412 |access-date=2024-10-29 |website=[[GitHub]] |language=en}}</ref> Specialized syntax support for [[channel (programming)|channels]] and various pointer types were removed to simplify the language.<ref name=Klabnik2016ACMHistory/>{{rp|at=22:32}}\n\nAccording to Rust developer Steve Klabnik, Rust was influenced during this period by developers coming from [[C++]] (e.g., low-level performance of features), [[scripting language]]s (e.g., Cargo and package management), and [[functional programming]] (e.g., type systems development).<ref name=Klabnik2016ACMHistory/>{{rp|at=30:50}}\n\nGraydon Hoare stepped down from Rust in 2013.<ref name=\"MITTechReview\"/> After Hoare's departure, it evolved organically under a federated governance structure, with a \"core team\" of initially six people,<ref name=Klabnik2016ACMHistory/>{{rp|at=21:45}} around 30-40 developers total across various other teams,<ref name=Klabnik2016ACMHistory/>{{rp|at=22:22}} and a Request for Comments (RFC) process for new language features added in March 2014.<ref name=Klabnik2016ACMHistory/>{{rp|at=33:47}} The core team would grow to nine people by 2016<ref name=Klabnik2016ACMHistory/>{{rp|at=21:45}} with over 1600 proposed RFCs.<ref name=Klabnik2016ACMHistory/>{{rp|at=34:08}}\n\nAccording to Andrew Binstock writing for ''[[Dr. Dobb's Journal]]'' in January 2014, while Rust was \"widely viewed as a remarkably elegant language\", adoption slowed because it radically changed from version to version.<ref>{{cite news |last=Binstock |first=Andrew |date=January 7, 2014 |title=The Rise And Fall of Languages in 2013 |website=[[Dr. Dobb's Journal]] |url=https://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |url-status=dead |archive-url=https://web.archive.org/web/20160807075745/http://www.drdobbs.com/jvm/the-rise-and-fall-of-languages-in-2013/240165192 |archive-date=2016-08-07 |access-date=2022-11-20}}</ref> Rust development at this time was focused on finalizing the language features and moving towards 1.0 so it could begin promising [[backward compatibility]].<ref name=Klabnik2016ACMHistory/>{{rp|at=41:26}}\n\nSix years after Mozilla sponsored its development, the first [[stable release]], Rust 1.0, was published on May 15, 2015.<ref name=\"MITTechReview\"/> A year after the release, the Rust compiler had accumulated over 1,400 contributors and there were over 5,000 third-party libraries published on the Rust package management website Crates.io.<ref name=Klabnik2016ACMHistory/>{{rp|at=43:15}}\n\n=== 2015–2020: Servo and early adoption ===\n\n[[File:Home page servo v0.01.png|thumb|right|Early homepage of Mozilla's [[Servo (software)|Servo browser engine]]]]\n\nThe development of the [[Servo (software)|Servo browser engine]] continued in parallel with Rust, jointly funded by Mozilla and [[Samsung]].<ref>{{cite news|last=Lardinois|first=Frederic|date=2015-04-03|title=Mozilla And Samsung Team Up To Develop Servo, Mozilla's Next-Gen Browser Engine For Multicore Processors|work=[[TechCrunch]]|url=https://techcrunch.com/2013/04/03/mozilla-and-samsung-collaborate-on-servo-mozillas-next-gen-browser-engine-for-tomorrows-multicore-processors/|access-date=2017-06-25|archive-date=2016-09-10|archive-url=https://web.archive.org/web/20160910211537/https://techcrunch.com/2013/04/03/mozilla-and-samsung-collaborate-on-servo-mozillas-next-gen-browser-engine-for-tomorrows-multicore-processors/|url-status=live}}</ref> The teams behind the two projects worked in close collaboration; new features in Rust were tested out by the Servo team, and new features in Servo were used to give feedback back to the Rust team.<ref name=Klabnik2016ACMHistory/>{{rp|at=5:41}} The first version of Servo was released in 2016.<ref name=\"MITTechReview\"/> The [[Firefox]] web browser shipped with Rust code as of 2016 (version 45),<ref name=Klabnik2016ACMHistory/>{{rp|at=53:30}}<ref>{{Cite web |title=Firefox 45.0, See All New Features, Updates and Fixes |url=https://www.mozilla.org/en-US/firefox/45.0/releasenotes/ |access-date=2024-10-31 |website=Mozilla |language=en |archive-date=2016-03-17  |archive-url=https://web.archive.org/web/20160317215950/https://www.mozilla.org/en-US/firefox/45.0/releasenotes/ |url-status=live }}</ref> but components of Servo did not appear in Firefox until September 2017 (version 57) as part of the [[Gecko (software)|Gecko]] and [[Gecko (software)#Quantum|Quantum]] projects.<ref>{{Cite web |last=Lardinois |first=Frederic |date=2017-09-29 |title=It's time to give Firefox another chance |url=https://techcrunch.com/2017/09/29/its-time-to-give-firefox-another-chance/ |access-date=2023-08-15 |website=[[TechCrunch]] |language=en-US |archive-date=2023-08-15  |archive-url=https://web.archive.org/web/20230815025149/https://techcrunch.com/2017/09/29/its-time-to-give-firefox-another-chance/ |url-status=live }}</ref>\n\nImprovements were made to the Rust toolchain ecosystem during the years following 1.0 including [[#Rustfmt|Rustfmt]], [[integrated development environment]] integration,<ref name=Klabnik2016ACMHistory/>{{rp|at=44:56}} and a regular compiler testing and release cycle.<ref name=Klabnik2016ACMHistory/>{{rp|at=46:48}} Rust also gained a community [[code of conduct]] and an [[IRC]] chat for community discussion.<ref name=Klabnik2016ACMHistory/>{{rp|at=50:36}}\n\nThe earliest known adoption outside of Mozilla was by individual projects at Samsung, [[Facebook]] (now [[Meta Platforms]]), [[Dropbox]], and Tilde, Inc. (the company behind [[ember.js]]).<ref name=Klabnik2016ACMHistory/>{{rp|at=55:44}}<ref name=\"MITTechReview\"/> [[Amazon Web Services]] followed in 2020.<ref name=\"MITTechReview\"/> Engineers acknowledged the risks of adopting a new technology; they cited performance, lack of a garbage collector, safety, and pleasantness of working in the language as reasons for the adoption. Amazon developers cited a finding by Portuguese researchers that Rust code used [[Energy efficiency in computing|less energy]] compared to similar code written in [[Java (programming language)|Java]].<ref name=\"MITTechReview\"/><ref name=2017PortugalEnergyStudy>{{Cite book |last1=Pereira |first1=Rui |last2=Couto |first2=Marco |last3=Ribeiro |first3=Francisco |last4=Rua |first4=Rui |last5=Cunha |first5=Jácome |last6=Fernandes |first6=João Paulo |last7=Saraiva |first7=João |chapter=Energy efficiency across programming languages: How do energy, time, and memory relate? |date=2017-10-23 |title=Proceedings of the 10th ACM SIGPLAN International Conference on Software Language Engineering |chapter-url=https://dl.acm.org/doi/10.1145/3136014.3136031 |series=SLE 2017 |location=New York, NY, USA |publisher=Association for Computing Machinery |pages=256–267 |doi=10.1145/3136014.3136031 |hdl=1822/65359 |isbn=978-1-4503-5525-4 |url=http://repositorio.inesctec.pt/handle/123456789/5492 }}</ref>\n\n=== 2020–present: Mozilla layoffs and Rust Foundation ===\n\nIn August 2020, Mozilla laid off 250 of its 1,000 employees worldwide, as part of a corporate restructuring caused by the [[COVID-19 pandemic]].<ref>{{cite web |url=https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |title=Mozilla lays off 250 employees while it refocuses on commercial products |last=Cimpanu |first=Catalin |website=[[ZDNET]] |access-date=2020-12-02 |date=2020-08-11 |archive-date=March 18, 2022 |archive-url=https://web.archive.org/web/20220318025804/https://www.zdnet.com/article/mozilla-lays-off-250-employees-while-it-refocuses-on-commercial-products/ |url-status=live}}</ref><ref>{{cite web |url=https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |title=Mozilla lays off 250 employees due to the pandemic |website=[[Engadget]] |last=Cooper |first=Daniel |access-date=2020-12-02 |date=2020-08-11 |archive-date=2020-12-13 |archive-url=https://web.archive.org/web/20201213020220/https://www.engadget.com/mozilla-firefox-250-employees-layoffs-151324924.html |url-status=live}}</ref> The team behind Servo was disbanded. The event raised concerns about the future of Rust.<ref>{{Cite web |last=Tung |first=Liam |date=2020-08-21 |title=Programming language Rust: Mozilla job cuts have hit us badly but here's how we'll survive |url=https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |access-date=2022-04-21 |website=[[ZDNET]] |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421083509/https://www.zdnet.com/article/programming-language-rust-mozilla-job-cuts-have-hit-us-badly-but-heres-how-well-survive/ |url-status=live}}</ref> In the following week, the Rust Core Team acknowledged the severe impact of the layoffs and announced that plans for a Rust foundation were underway. The first goal of the foundation would be to take ownership of all [[trademark]]s and [[domain name]]s and to take financial responsibility for their costs.<ref>{{cite web |url=https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |title=Laying the foundation for Rust's future |website=Rust Blog |access-date=2020-12-02 |date=2020-08-18 |archive-date=2020-12-02 |archive-url=https://web.archive.org/web/20201202022933/https://blog.rust-lang.org/2020/08/18/laying-the-foundation-for-rusts-future.html |url-status=live}}</ref>\n\nOn February 8, 2021, the formation of the [[#Rust Foundation|Rust Foundation]] was announced by five founding companies: [[Amazon Web Services]], [[Google]], [[Huawei]], [[Microsoft]], and [[Mozilla]].<ref>{{Cite web |date=2020-02-08 |title=Hello World! |url=https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |access-date=2022-06-04 |website=Rust Foundation |language=en |archive-date=April 19, 2022 |archive-url=https://web.archive.org/web/20220419124635/https://foundation.rust-lang.org/news/2021-02-08-hello-world/ |url-status=live}}</ref><ref>{{Cite web|date=2021-02-09|title=Mozilla Welcomes the Rust Foundation |website=Mozilla Blog |url=https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation |archive-url=https://web.archive.org/web/20210208212031/https://blog.mozilla.org/blog/2021/02/08/mozilla-welcomes-the-rust-foundation/|archive-date=2021-02-08|access-date=2021-02-09|url-status=live}}</ref> The foundation would provide financial support for Rust developers in the form of grants and server funding.<ref name=\"MITTechReview\"/> In a blog post published on April 6, 2021, Google announced support for Rust within the [[Android Open Source Project]] as an alternative to C/C++.<ref>{{Cite web|last=Amadeo|first=Ron|date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2021-04-08|website=Ars Technica|language=en-us|archive-date=2021-04-08|archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/|url-status=live}}</ref>\n\nOn November 22, 2021, the Moderation Team, which was responsible for enforcing the community code of conduct, announced their resignation \"in protest of the Core Team placing themselves unaccountable to anyone but themselves\".<ref name=\"moderation\">{{Cite news |first=Tim |last=Anderson |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |date=2021-11-23 |access-date=2022-08-04 |website=[[The Register]] |language=en |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714093245/https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |url-status=live }}</ref> In May 2022, the Rust Core Team, other lead programmers, and members of the Rust Foundation board implemented governance reforms in response to the incident.<ref>{{Cite web |title=Governance Update |first1=Ryan |last1=Levick |first2=Mara |last2=Bos |url=https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html |access-date=2022-10-27 |website=Inside Rust Blog |language=en |archive-date=2022-10-27  |archive-url=https://web.archive.org/web/20221027030926/https://blog.rust-lang.org/inside-rust/2022/05/19/governance-update.html |url-status=live }}</ref>\n\nThe Rust Foundation posted a draft for a new trademark policy on April 6, 2023, which resulted in widespread negative reactions from Rust users and contributors.<ref name=ApologizesTrademarkPolicy>{{Cite news |last=Claburn |first=Thomas |title=Rust Foundation apologizes for trademark policy confusion |date=2023-04-17 |url=https://www.theregister.com/2023/04/17/rust_foundation_apologizes_trademark_policy/ |access-date=2023-05-07 |website=[[The Register]] |language=en |archive-date=2023-05-07  |archive-url=https://web.archive.org/web/20230507053637/https://www.theregister.com/2023/04/17/rust_foundation_apologizes_trademark_policy/ |url-status=live }}</ref> The trademark policy included rules for how the Rust logo and name could be used.<ref name=ApologizesTrademarkPolicy/>\n\nOn February 26, 2024, the U.S. [[White House]] [[Office of the National Cyber Director]] released a 19-page press report urging software development to move away from C and C++ to memory-safe languages like C#, Go, Java, Ruby, Swift, and Rust.<ref name=WhiteHouse1>{{Cite web |last=Gross |first=Grant |title=White House urges developers to dump C and C++ |url=https://www.infoworld.com/article/2336216/white-house-urges-developers-to-dump-c-and-c.html |date=2024-02-27 |access-date=2025-01-26 |website=[[InfoWorld]] |language=en}}</ref><ref name=WhiteHouse2>{{Cite web |last=Warminsky |first=Joe |date=2024-02-27 |title=After decades of memory-related software bugs, White House calls on industry to act |url=https://therecord.media/memory-related-software-bugs-white-house-code-report-oncd |access-date=2025-01-26 |website=The Record |language=en}}</ref><ref name=WhiteHouseFullReport>{{Cite web |date=2024-02-26 |title=Press Release: Future Software Should Be Memory Safe |url=https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/ |archive-url=https://web.archive.org/web/20250118013136/https://www.whitehouse.gov/oncd/briefing-room/2024/02/26/press-release-technical-report/ |publisher=[[White House|The White House]] |url-status=dead |archive-date=2025-01-18 |access-date=2025-01-26 }}</ref>\n\n== Syntax and features ==\n{{Main|Rust syntax}}\nRust's [[Syntax (programming languages)|syntax]] is similar to that of [[C (programming language)|C]] and C++,<ref>{{Cite news |last=Proven |first=Liam |date=2019-11-27 |title=Rebecca Rumbul named new CEO of The Rust Foundation |url=https://www.theregister.com/2021/11/19/rust_foundation_ceo/ |access-date=2022-07-14 |website=[[The Register]] |language=en |quote=\"Both are curly bracket languages, with C-like syntax that makes them unintimidating for C programmers.\" |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714110957/https://www.theregister.com/2021/11/19/rust_foundation_ceo/ |url-status=live }}</ref><ref name=\":4\" /> although many of its features were influenced by [[functional programming]] languages such as [[OCaml]].{{sfn|Klabnik|Nichols|2019|p=263}} Hoare has described Rust as targeted at frustrated C++ developers and emphasized features such as safety, control of [[memory layout]], and [[Concurrency (computer science)|concurrency]].<ref name=Hoare2010/> Safety in Rust includes the guarantees of memory safety, type safety, and lack of data races.\n\n=== Hello World program ===\nBelow is a [[\"Hello, World!\" program]] in Rust. The {{Rust|fn}} keyword denotes a [[Function (computer programming)|function]], and the {{Rust|println!}} [[Macro (computer science)|macro]] (see {{Section link|2=Macros|nopage=y}}) prints the message to [[standard output]].{{sfn|Klabnik|Nichols|2019|pp=5–6}} [[Statement (computer science)|Statements]] in Rust are separated by [[Semicolon#Programming|semicolons]].\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    println!(\"Hello, World!\");\n}\n</syntaxhighlight>\n\n=== Variables ===\n[[Variable (computer science)|Variables]] in Rust are defined through the {{rust|let}} keyword.{{sfn|Klabnik|Nichols|2023|p=32}} The example below assigns a value to the variable with name {{rust|foo}} of type {{rust|i32}} and outputs its value; the type annotation {{rust|: i32}} can also be omitted.\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let foo: i32 = 10;\n    println!(\"The value of foo is {foo}\");\n}\n</syntaxhighlight>\n\nVariables are [[Immutable object|immutable]] by default, but adding the {{rust|mut}} keyword allows the variable to be mutated.{{sfn|Klabnik|Nichols|2023|pp=32-33}} The following example uses {{rust|//}}, which denotes the start of a [[Comment (computer programming)|comment]].{{sfn|Klabnik|Nichols|2023|pp=49-50}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // This code would not compile without adding \"mut\".\n    let mut foo = 10; \n    println!(\"The value of foo is {foo}\");\n    foo = 20;\n    println!(\"The value of foo is {foo}\");\n}\n</syntaxhighlight>\n\nMultiple {{rust|let}} expressions can define multiple variables with the same name, known as [[variable shadowing]]. Variable shadowing allows transforming variables without having to name the variables differently.{{sfn|Klabnik|Nichols|2023|pp=34-36}} The example below declares a new variable with the same name that is double the original value:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let foo = 10;\n    // This will output \"The value of foo is 10\"\n    println!(\"The value of foo is {foo}\");\n    let foo = foo * 2;\n    // This will output \"The value of foo is 20\"\n    println!(\"The value of foo is {foo}\");\n}\n</syntaxhighlight>\n\nVariable shadowing is also possible for values of different types. For example, going from a string to its length:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let letters = \"abc\";\n    let letters = letters.len();\n}\n</syntaxhighlight>\n\n=== Block expressions and control flow ===\n\nA ''block expression'' is delimited by [[Bracket#Curly brackets|curly brackets]]. When the last expression inside a block does not end with a semicolon, the block evaluates to the value of that trailing expression:{{sfn|Klabnik|Nichols|2023|pp=6,47,53}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = {\n        println!(\"this is inside the block\");\n        1 + 2\n    };\n    println!(\"1 + 2 = {x}\");\n}\n</syntaxhighlight>\n\nTrailing expressions of function bodies are used as the return value:{{sfn|Klabnik|Nichols|2023|pp=47-48}}\n\n<syntaxhighlight lang=\"rust\">\nfn add_two(x: i32) -> i32 {\n    x + 2\n}\n</syntaxhighlight>\n\n==== {{rust|if}} expressions ====\n\nAn {{rust|if}} [[conditional expression]] executes code based on whether the given value is {{rust|true}}. {{rust|else}} can be used for when the value evaluates to {{rust|false}}, and {{rust|else if}} can be used for combining multiple expressions.{{sfn|Klabnik|Nichols|2023|pp=50-53}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 10;\n    if x > 5 {\n        println!(\"value is greater than five\");\n    }\n\n    if x % 7 == 0 {\n        println!(\"value is divisible by 7\");\n    } else if x % 5 == 0 {\n        println!(\"value is divisible by 5\");\n    } else {\n        println!(\"value is not divisible by 7 or 5\");\n    }\n}\n</syntaxhighlight>\n\n{{rust|if}} and {{rust|else}} blocks can evaluate to a value, which can then be assigned to a variable:{{sfn|Klabnik|Nichols|2023|pp=50-53}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 10;\n    let new_x = if x % 2 == 0 { x / 2 } else { 3 * x + 1 };\n    println!(\"{new_x}\");\n}\n</syntaxhighlight>\n\n==== {{rust|while}} loops ====\n<code>[[While loop|while]]</code> can be used to repeat a block of code while a condition is met.{{sfn|Klabnik|Nichols|2023|p=56}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // Iterate over all integers from 4 to 10\n    let mut value = 4;\n    while value <= 10 {\n         println!(\"value = {value}\");\n         value += 1;\n    }\n}\n</syntaxhighlight>\n\n==== {{rust|for}} loops and iterators ====\n\n[[For loop]]s in Rust loop over elements of a collection.{{sfn|Klabnik|Nichols|2023|pp=57-58}}\n{{rust|for}} expressions work over any [[iterator]] type.\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    // Using `for` with range syntax for the same functionality as above\n    // The syntax 4..=10 means the range from 4 to 10, up to and including 10.\n    for value in 4..=10 {\n        println!(\"value = {value}\");\n    }\n}\n</syntaxhighlight>\n\nIn the above code, {{rust|1=4..=10}} is a value of type {{rust|Range}} which implements the {{rust|Iterator}} trait. The code within the curly braces is applied to each element returned by the iterator.\n\nIterators can be combined with functions over iterators like {{rust|map}}, {{rust|filter}}, and {{rust|sum}}. For example, the following adds up all numbers between 1 and 100 that are multiples of 3:\n\n<syntaxhighlight lang=\"rust\">\n(1..=100).filter(|x: &u32| -> bool { x % 3 == 0 }).sum()\n</syntaxhighlight>\n\n==== {{rust|loop}} and {{rust|break}} statements ====\n\nMore generally, the {{rust|loop}} keyword allows repeating a portion of code until a {{rust|break}} occurs. {{rust|break}} may optionally exit the loop with a value. In the case of nested loops, labels denoted by {{rust|'label_name}} can be used to break an outer loop rather than the innermost loop.{{sfn|Klabnik|Nichols|2023|pp=54-56}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let value = 456;\n    let mut x = 1;\n    let y = loop {\n        x *= 10;\n        if x > value {\n            break x / 10;\n        }\n    };\n    println!(\"largest power of ten that is smaller than or equal to value: {y}\");\n\n    let mut up = 1;\n    'outer: loop {\n        let mut down = 120;\n        loop {\n            if up > 100 {\n                break 'outer;\n            }\n\n            if down < 4 {\n                break;\n            }\n\n            down /= 2;\n            up += 1;\n            println!(\"up: {up}, down: {down}\");\n        }\n        up *= 2;\n    }\n}\n</syntaxhighlight>\n\n=== Pattern matching ===\nThe {{rust|match}} and {{rust|if let}} expressions can be used for [[pattern matching]]. For example, {{rust|match}} can be used to double an optional integer value if present, and return zero otherwise:{{sfn|Klabnik|Nichols|2019|pp=104–109}}\n\n<syntaxhighlight lang=\"rust\">\nfn double(x: Option<u64>) -> u64 {\n    match x {\n        Some(y) => y * 2,\n        None => 0,\n    }\n}\n</syntaxhighlight>\n\nEquivalently, this can be written with {{rust|if let}} and {{rust|else}}:\n\n<syntaxhighlight lang=\"rust\">\nfn double(x: Option<u64>) -> u64 {\n    if let Some(y) = x {\n        y * 2\n    } else {\n        0\n    }\n}\n</syntaxhighlight>\n\n=== Types ===\nRust is [[strongly typed]] and [[statically typed]], meaning that the types of all variables must be known at compilation time. Assigning a value of a particular type to a differently typed variable causes a [[compilation error]]. [[Type inference]] is used to determine the type of variables if unspecified.{{sfn|Klabnik|Nichols|2019|pp=24}}\n\nThe type <code>()</code>, called the \"unit type\" in Rust, is a concrete type that has exactly one value. It occupies no memory (as it represents the absence of value). All functions that do not have an indicated return type implicitly return <code>()</code>. It is similar to {{cpp|void}} in other C-style languages, however {{cpp|void}} denotes the absence of a type and cannot have any value.\n\nThe default integer type is {{rust|i32}}, and the default [[floating point]] type is {{rust|f64}}. If the type of a [[Literal (computer programming)|literal]] number is not explicitly provided, it is either inferred from the context or the default type is used.{{sfn|Klabnik|Nichols|2019|pp=36–38}}\n\n==== Primitive types ====\n[[Integer type]]s in Rust are named based on the [[signedness]] and the number of bits the type takes. For example, {{rust|i32}} is a signed integer that takes 32 bits of storage, whereas {{rust|u8}} is unsigned and only takes 8 bits of storage. {{rust|isize}} and {{rust|usize}} take storage depending on the [[Bus (computing)#Address bus|memory address bus width]] of the compilation target. For example, when building for [[32-bit computing|32-bit target]]s, both types will take up 32 bits of space.<ref>{{cite web|title=isize|url=https://doc.rust-lang.org/stable/std/primitive.isize.html|website=doc.rust-lang.org|access-date=2025-09-28}}</ref><ref>{{cite web|title=usize|url=https://doc.rust-lang.org/stable/std/primitive.usize.html|website=doc.rust-lang.org|access-date=2025-09-28}}</ref>\n\nBy default, integer literals are in base-10, but different [[radix|radices]] are supported with prefixes, for example, {{rust|0b11}} for [[binary number]]s, {{rust|0o567}} for [[octal]]s, and {{rust|0xDB}} for [[hexadecimal]]s. By default, integer literals default to {{rust|i32}} as its type. Suffixes such as {{rust|4u32}} can be used to explicitly set the type of a literal.{{sfn|Klabnik|Nichols|2023|pp=36-38}} Byte literals such as {{rust|b'X'}} are available to represent the [[ASCII]] value (as a {{rust|u8}}) of a specific character.{{sfn|Klabnik|Nichols|2023|p=502}}\n\nThe [[Boolean type]] is referred to as {{rust|bool}} which can take a value of either {{rust|true}} or {{rust|false}}. A {{rust|char}} takes up 32 bits of space and represents a Unicode scalar value:<ref>{{Cite web |title=Primitive Type char |url=https://doc.rust-lang.org/std/primitive.char.html |website=The Rust Standard Library documentation |access-date=7 September 2025 }}</ref> a [[Unicode codepoint]] that is not a [[Universal Character Set characters#Surrogates|surrogate]].<ref>{{Cite web |title=Glossary of Unicode Terms |url=https://www.unicode.org/glossary/ |access-date=2024-07-30 |website=[[Unicode Consortium]] |archive-date=2018-09-24  |archive-url=https://web.archive.org/web/20180924092749/http://www.unicode.org/glossary/ |url-status=live }}</ref> [[IEEE 754]] floating point numbers are supported with {{rust|f32}} for [[single precision float]]s and {{rust|f64}} for [[double precision float]]s.{{sfn|Klabnik|Nichols|2019|pp=38–40}}\n\n==== Compound types ====\n\nCompound types can contain multiple values. Tuples are fixed-size lists that can contain values whose types can be different. Arrays are fixed-size lists whose values are of the same type. Expressions of the tuple and array types can be written through listing the values, and can be accessed with {{rust|.index}} or {{rust|[index]}}:{{sfn|Klabnik|Nichols|2023|pp=40-42}}\n\n<syntaxhighlight lang=\"rust\">\nlet tuple: (u32, bool) = (3, true);\nlet array: [i8; 5] = [1, 2, 3, 4, 5];\nlet value = tuple.1; // true\nlet value = array[2]; // 3\n</syntaxhighlight>\n\nArrays can also be constructed through copying a single value a number of times:{{sfn|Klabnik|Nichols|2023|p=42}}\n\n<syntaxhighlight lang=\"rust\">\nlet array2: [char; 10] = [' '; 10]; \n</syntaxhighlight>\n<!-- todo str, and ! -->\n\n=== Ownership and references ===\n\nRust's ownership system consists of rules that ensure memory safety without using a garbage collector. At compile time, each value must be attached to a variable called the ''owner'' of that value, and every value must have exactly one owner.{{sfn|Klabnik|Nichols|2019|pp=59–61}} Values are moved between different owners through assignment or passing a value as a function parameter. Values can also be ''borrowed,'' meaning they are temporarily passed to a different function before being returned to the owner.{{sfn|Klabnik|Nichols|2019|pp=63–68}} With these rules, Rust can prevent the creation and use of [[dangling pointers]]:{{sfn|Klabnik|Nichols|2019|pp=63–68}}{{sfn|Klabnik|Nichols|2019|pp=74–75}}\n\n<syntaxhighlight lang=\"rust\">\nfn print_string(s: String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"Hello, World\");\n    print_string(s); // s consumed by print_string\n    // s has been moved, so cannot be used any more\n    // another print_string(s); would result in a compile error\n}\n</syntaxhighlight>\n\nThe function {{rust|print_string}} takes ownership over the {{rust|String}} value passed in; Alternatively, {{rust|&}} can be used to indicate a [[Reference (computer science)|reference]] type (in {{rust|&String}}) and to create a reference (in {{rust|&s}}):{{sfn|Klabnik|Nichols|2023|pp=71–72}}\n\n<syntaxhighlight lang=\"rust\">\nfn print_string(s: &String) {\n    println!(\"{}\", s);\n}\n\nfn main() {\n    let s = String::from(\"Hello, World\");\n    print_string(&s); // s borrowed by print_string\n    print_string(&s); // s has not been consumed; we can call the function many times\n}\n</syntaxhighlight>\n\nBecause of these ownership rules, Rust types are known as ''[[linear types|linear]]'' or ''affine'' types, meaning each value can be used exactly once. This enforces a form of [[software fault isolation]] as the owner of a value is solely responsible for its correctness and deallocation.<ref name=\"BeyondSafety\">{{Cite book |last1=Balasubramanian |first1=Abhiram |last2=Baranowski |first2=Marek S. |last3=Burtsev |first3=Anton |last4=Panda |first4=Aurojit |last5=Rakamarić |first5=Zvonimir |last6=Ryzhyk |first6=Leonid |title=Proceedings of the 16th Workshop on Hot Topics in Operating Systems |chapter=System Programming in Rust |date=2017-05-07 |chapter-url=https://doi.org/10.1145/3102980.3103006 |series=HotOS '17 |location=New York, NY, US |publisher=Association for Computing Machinery |pages=156–161 |doi=10.1145/3102980.3103006 |isbn=978-1-4503-5068-6 |s2cid=24100599 |access-date=June 1, 2022 |archive-date=June 11, 2022 |archive-url=https://web.archive.org/web/20220611034046/https://dl.acm.org/doi/10.1145/3102980.3103006 |url-status=live}}</ref>\n\nWhen a value goes out of scope, it is ''dropped'' by running its [[Destructor (computer programming)|destructor]]. The destructor may be programmatically defined through implementing the {{rust|Drop}} [[#Traits|trait]]. This helps manage resources such as file handles, network sockets, and [[Lock (computer science)|locks]], since when objects are dropped, the resources associated with them are closed or released automatically.{{sfn|Klabnik|Nichols|2023|pp=327-30}}\n\n==== Lifetimes ====\n\n[[Object lifetime]] refers to the period of time during which a reference is valid; that is, the time between the object creation and destruction.<ref>{{Cite web |title=Lifetimes |url=https://doc.rust-lang.org/rust-by-example/scope/lifetime.html |access-date=2024-10-29 |website=Rust by Example |archive-date=2024-11-16  |archive-url=https://web.archive.org/web/20241116192422/https://doc.rust-lang.org/rust-by-example/scope/lifetime.html |url-status=live }}</ref> These ''lifetimes'' are implicitly associated with all Rust reference types. While often inferred, they can also be indicated explicitly with named lifetime parameters (often denoted {{rust|'a}}, {{rust|'b}}, and so on).<ref>{{Cite web |title=Explicit annotation |url=https://doc.rust-lang.org/rust-by-example/scope/lifetime/explicit.html |access-date=2024-10-29 |website=Rust by Example}}</ref>\n\nLifetimes in Rust can be thought of as [[Scope (computer science)|lexically scoped]], meaning that the duration of an object lifetime is inferred from the set of locations in the source code (i.e., function, line, and column numbers) for which a variable is valid.{{sfn|Klabnik|Nichols|2019|p=194}} For example, a reference to a local variable has a lifetime corresponding to the block it is defined in:{{sfn|Klabnik|Nichols|2019|p=194}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let x = 5;                // ------------------+- Lifetime 'a\n                              //                   |\n    let r = &x;               // -+-- Lifetime 'b  |\n                              //  |                |\n    println!(\"r: {}\", r);     //  |                |\n                              //  |                |\n                              // -+                |\n}                             // ------------------+\n</syntaxhighlight>\n\nThe borrow checker in the Rust compiler then enforces that references are only used in the locations of the source code where the associated lifetime is valid.{{sfn|Klabnik|Nichols|2019|pp=75,134}}<ref>{{Cite web |last=Shamrell-Harrington |first=Nell |date=2022-04-15 |title=The Rust Borrow Checker – a Deep Dive |url=https://www.infoq.com/presentations/rust-borrow-checker/ |access-date=2022-06-25 |website=InfoQ |language=en |archive-date=2022-06-25  |archive-url=https://web.archive.org/web/20220625140128/https://www.infoq.com/presentations/rust-borrow-checker/ |url-status=live }}</ref> In the example above, storing a reference to variable {{rust|x}} in {{rust|r}} is valid, as variable {{rust|x}} has a longer lifetime ({{rust|'a}}) than variable {{rust|r}} ({{rust|'b}}). However, when {{rust|x}} has a shorter lifetime, the borrow checker would reject the program:\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let r;                    // ------------------+- Lifetime 'a\n                              //                   |\n    {                         //                   |\n        let x = 5;            // -+-- Lifetime 'b  |\n        r = &x; // ERROR: x does  |                |\n    }           // not live long -|                |\n                // enough                          |\n    println!(\"r: {}\", r);     //                   |\n}                             // ------------------+\n</syntaxhighlight>\n\nSince the lifetime of the referenced variable ({{rust|'b}}) is shorter than the lifetime of the variable holding the reference ({{rust|'a}}), the borrow checker errors, preventing {{rust|x}} from being used from outside its scope.{{sfn|Klabnik|Nichols|2019|pp=194-195}}\n\nLifetimes can be indicated using explicit ''lifetime parameters'' on function arguments. For example, the following code specifies that the reference returned by the function has the same lifetime as {{rust|original}} (and ''not'' necessarily the same lifetime as {{rust|prefix}}):{{sfn|Klabnik|Nichols|2023|pp=208–12}}\n\n<syntaxhighlight lang=\"rust\">\nfn remove_prefix<'a>(mut original: &'a str, prefix: &str) -> &'a str {\n    if original.starts_with(prefix) {\n        original = original[prefix.len()..];\n    }\n    original\n}\n</syntaxhighlight>\n\nIn the compiler, ownership and lifetimes work together to prevent memory safety issues such as dangling pointers.{{sfn|Klabnik|Nichols|2023|loc=[https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html 4.2. References and Borrowing]}}<ref name=\"Pearce\">{{cite journal |last1=Pearce |first1=David |title=A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust |url=https://dl.acm.org/doi/10.1145/3443420 |journal=ACM Transactions on Programming Languages and Systems |access-date=11 December 2024 |archive-url=https://web.archive.org/web/20240415053627/https://dl.acm.org/doi/10.1145/3443420 |archive-date=15 April 2024 |doi=10.1145/3443420 |date=17 April 2021 |volume=43 |pages=1–73 |url-status=live}}</ref>\n\n=== User-defined types ===\nUser-defined types are created with the {{rust|struct}} or {{rust|enum}} keywords. The {{rust|struct}} keyword is used to denote a [[Record (computer science)|record type]] that groups multiple related values.{{sfn|Klabnik|Nichols|2019|p=83}} {{rust|enum}}s can take on different variants at runtime, with its capabilities similar to [[algebraic data types]] found in functional programming languages.{{sfn|Klabnik|Nichols|2019|p=97}} Both records and enum variants can contain [[Field (computer science)|fields]] with different types.{{sfn|Klabnik|Nichols|2019|pp=98–101}} Alternative names, or aliases, for the same type can be defined with the {{rust|type}} keyword.{{sfn|Klabnik|Nichols|2019|pp=438–440}}\n\nThe {{rust|impl}} keyword can define methods for a user-defined type. Data and functions are defined separately. Implementations fulfill a role similar to that of [[Class (programming)|classes]] within other languages.{{sfn|Klabnik|Nichols|2019|pp=93}}\n\n==== Standard library ====\n[[File:Rust standard libraries.svg|thumb|A diagram of the dependencies between the standard library modules of Rust.]]\nThe Rust [[standard library]] defines and implements many widely used custom data types, including core data structures such as {{rust|Vec}}, {{rust|Option}}, and {{rust|HashMap}}, as well as [[smart pointer]] types. Rust also provides a way to exclude most of the standard library using the attribute {{rust|#![no_std]}}, for applications such as embedded devices. Internally, the standard library is divided into three parts, {{rust|core}}, {{rust|alloc}}, and {{rust|std}}, where {{rust|std}} and {{rust|alloc}} are excluded by {{rust|#![no_std]}}.{{sfn|Gjengset|2021|pp=213-215}}\n\nRust uses the [[option type]] <code>Option<T></code> to define optional values, which can be matched using <code>if let</code> or <code>match</code> to access the inner value:{{sfn|Klabnik|Nichols|2023|pp=108-110,113-114,116-117}}\n\n<syntaxhighlight lang=\"rust\">\nfn main() {\n    let name1: Option<&str> = None;\n    // In this case, nothing will be printed out\n    if let Some(name) = name1 {\n        println!(\"{name}\");\n    }\n\n    let name2: Option<&str> = Some(\"Matthew\");\n    // In this case, the word \"Matthew\" will be printed out\n    if let Some(name) = name2 {\n        println!(\"{name}\");\n    }\n}\n</syntaxhighlight>\n\nSimilarly, Rust's [[result type]] <code>Result<T, E></code> holds either a successfully computed value (the <code>Ok</code> variant) or an error (the <code>Err</code> variant)<ref name=\"Rust error handling\">{{cite web |title=Rust error handling is perfect actually |url=https://bitfieldconsulting.com/posts/rust-errors-option-result |website=Bitfield Consulting |access-date=15 Sep 2025 |archive-date=2025-08-07 |archive-url=https://web.archive.org/web/20250807061432/https://bitfieldconsulting.com/posts/rust-errors-option-result |url-status=live }}</ref>. Like <code>Option</code>, the use of <code>Result</code> means that the inner value cannot be used directly; programmers must use a <code>match</code> expression, syntactic sugar such as <code>?</code> (the “try” operator), or an explicit <code>unwrap</code> assertion to access it. Both <code>Option</code> and <code>Result</code> are used throughout the standard library and are a fundamental part of Rust's explicit approach to handling errors and missing data.\n\n=== Pointers ===\nThe <code>&</code> and {{rust|&mut}} reference types are guaranteed to not be null and point to valid memory.{{sfn|Gjengset|2021|p=155-156}} The raw pointer types {{rust|*const}} and {{rust|*mut}} opt out of the safety guarantees, thus they may be null or invalid; however, it is impossible to dereference them unless the code is explicitly declared unsafe through the use of an {{rust|unsafe}} block.{{sfn|Klabnik|Nichols|2023|pp=421-423}} Unlike dereferencing, the creation of raw pointers is allowed inside safe Rust code.{{sfn|Klabnik|Nichols|2019|pp=418–427}}\n\n=== Type conversion ===\n{{excerpt|Type conversion|Rust}}\n\n[[File:Rust 101.webm|thumb|A presentation on Rust by Emily Dunham from [[Mozilla]]'s Rust team ([[linux.conf.au]] conference, Hobart, 2017)]]\n\n=== Polymorphism ===\nRust supports [[bounded parametric polymorphism]] through [[Trait (computer programming)|traits]] and [[generic function]]s.{{sfn|Klabnik|Nichols|2023|p=378}} Common behavior between types may be declared using traits and {{rust|impl}}s:{{sfn|Klabnik|Nichols|2023|pp=192-198}}\n\n<syntaxhighlight lang=\"rust\">\ntrait Zero: Sized {\n    fn zero() -> Self;\n    fn is_zero(&self) -> bool\n    where\n        Self: PartialEq,\n    {\n        self == &Zero::zero()\n    }\n}\n\nimpl Zero for u32 {\n    fn zero() -> u32 { 0 }\n}\n\nimpl Zero for f32 {\n    fn zero() -> Self { 0.0 }\n}\n</syntaxhighlight>\n\nThe example above also includes a method {{rust|is_zero}} which provides a default implementation that is not required when implementing the trait.{{sfn|Klabnik|Nichols|2023|pp=192-198}}\n\nA function can then be made generic by adding type parameters inside angle brackets ({{rust|<Num>}}), which only allow types that implement the trait:\n\n<syntaxhighlight lang=\"rust\">\n// zero is a generic function with one type parameter, Num\nfn zero<Num: Zero>() -> Num {\n    Num::zero()\n}\n\nfn main() {\n    let a: u32 = zero();\n    let b: f32 = zero();\n    assert!(a.is_zero() && b.is_zero());\n}\n</syntaxhighlight>\n\nIn the examples above, {{rust|Num: Zero}} as well as {{rust|where Self: PartialEq}} are trait bounds that constrain the type to only allow types that implement {{rust|Zero}} or {{rust|PartialEq}}.{{sfn|Klabnik|Nichols|2023|pp=192-198}} Within a trait or impl, {{rust|Self}} refers to the type that the code is implementing.{{sfn|Klabnik|Nichols|2023|p=98}}\n\nGenerics can be used in functions to allow implementing a behavior for different types without repeating the same code. Generic functions can be written in relation to other generics, without knowing the actual type.{{sfn|Klabnik|Nichols|2019|pp=171–172,205}}\n\n==== Trait objects ====\nRust supports two ways to call trait methods. With generics and trait bounds, calls use [[static dispatch]]: the compiler [[Monomorphization|monomorphizes]] the function for each concrete type, yielding performance comparable to hand-written, type-specific code, at the cost of longer compile times and potentially larger binaries.{{sfn|Klabnik|Nichols|2023|pp=191-192}} When the exact type is not known at compile time, or when heterogeneous collections are needed, Rust provides [[Dynamic dispatch|trait objects]] (e.g., <code>&dyn Trait</code>, <code>Box<dyn Trait></code>). Trait-object calls use [[dynamic dispatch]] via a vtable; a trait object is a \"fat pointer\" carrying both a data pointer and a method table pointer.{{sfn|Klabnik|Nichols|2023|pp=191-192}} This indirection can inhibit inlining and add a small runtime cost, but it keeps a single copy of the code and can reduce binary size. Only object-safe traits are eligible to be used as trait objects.{{sfn|Gjengset|2021|p=25}}\n\nHowever, Rust also uses a feature known as ''trait objects'' to accomplish [[dynamic dispatch]], a type of polymorphism where the implementation of a polymorphic operation is chosen at [[Runtime (program lifecycle phase)|runtime]]. This allows for behavior similar to [[duck typing]], where all data types that implement a given trait can be treated as functionally equivalent.{{sfn|Klabnik|Nichols|2023|loc=[https://doc.rust-lang.org/book/ch18-02-trait-objects.html 18.2. Using Trait Objects That Allow for Values of Different Types]}} Trait objects are declared using the syntax <code>dyn Tr</code> where <code>Tr</code> is a trait. Trait objects are dynamically sized, therefore they must be put behind a pointer, such as <code>Box</code>.{{sfn|Klabnik|Nichols|2019|pp=441–442}} The following example creates a list of objects where each object can be printed out using the <code>Display</code> trait:\n\n<syntaxhighlight lang=\"Rust\">\nuse std::fmt::Display;\n\nlet v: Vec<Box<dyn Display>> = vec![\n    Box::new(3),\n    Box::new(5.0),\n    Box::new(\"hi\"),\n];\n\nfor x in v {\n    println!(\"{x}\");\n}\n</syntaxhighlight>\n\nIf an element in the list does not implement the <code>Display</code> trait, it will cause a compile-time error.{{sfn|Klabnik|Nichols|2019|pp=379–380}}\n\n=== Memory safety ===\nRust is designed to be [[memory safe]]. It does not permit null pointers, [[dangling pointer]]s, or [[data race]]s.<ref name=\"cnet\">{{cite web |url=http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |title=Samsung joins Mozilla's quest for Rust |last=Rosenblatt |first=Seth |date=2013-04-03 |publisher=[[CNET]] |access-date=2013-04-05 |archive-date=2013-04-04 |archive-url=https://web.archive.org/web/20130404142333/http://reviews.cnet.com/8301-3514_7-57577639/samsung-joins-mozillas-quest-for-rust/ |url-status=live}}</ref><ref name=\"lwn\">{{cite web |last=Brown |first=Neil |date=2013-04-17 |title=A taste of Rust |url=https://lwn.net/Articles/547145/ |url-status=live |archive-url=https://web.archive.org/web/20130426010754/http://lwn.net/Articles/547145/ |archive-date=2013-04-26 |access-date=2013-04-25 |website=[[LWN.net]]}}</ref><ref name=\"The Rustonomicon\">{{Cite web|url=https://doc.rust-lang.org/nomicon/races.html|title=Races|website=The Rustonomicon|access-date=2017-07-03|archive-date=2017-07-10|archive-url=https://web.archive.org/web/20170710194643/https://doc.rust-lang.org/nomicon/races.html|url-status=live}}</ref><ref name=\"Sensors\">{{cite journal |last1=Vandervelden |first1=Thibaut |last2=De Smet |first2=Ruben |last3=Deac |first3=Diana |last4=Steenhaut |first4=Kris |last5=Braeken |first5=An |title=Overview of Embedded Rust Operating Systems and Frameworks |journal= Sensors|doi=10.3390/s24175818 |date=7 September 2024 |volume=24 |issue=17 |page=5818 |doi-access=free |pmid=39275729 |pmc=11398098 |bibcode=2024Senso..24.5818V }}</ref> Data values can be initialized only through a fixed set of forms, all of which require their inputs to be already initialized.<ref name=\"lang-faq\">{{cite web |title=The Rust Language FAQ |publisher=The Rust Programming Language |url=http://static.rust-lang.org/doc/master/complement-lang-faq.html |url-status=dead |archive-url=https://web.archive.org/web/20150420104147/http://static.rust-lang.org/doc/master/complement-lang-faq.html |archive-date=2015-04-20 |year=2015 |access-date=2017-04-24}}</ref>\n\n=== Memory management ===\nRust does not use [[garbage collection (computer science)|garbage collection]]. Memory and other resources are instead managed through the \"resource acquisition is initialization\" convention,<ref>{{Cite web|title=RAII|url=https://doc.rust-lang.org/rust-by-example/scope/raii.html|access-date=2020-11-22|website=Rust by Example|archive-date=2019-04-21|archive-url=https://web.archive.org/web/20190421131142/https://doc.rust-lang.org/rust-by-example/scope/raii.html|url-status=live}}</ref> with optional [[reference counting]]. Rust provides deterministic management of resources, with very low [[Overhead (computing)|overhead]].<ref>{{Cite web|url=https://blog.rust-lang.org/2015/05/11/traits.html|title=Abstraction without overhead: traits in Rust|website=Rust Blog|access-date=October 19, 2021|archive-date=September 23, 2021|archive-url=https://web.archive.org/web/20210923101530/https://blog.rust-lang.org/2015/05/11/traits.html|url-status=live}}</ref> Values are [[Stack-based memory allocation|allocated on the stack]] by default, and all [[dynamic allocation]]s must be explicit.<ref>{{Cite web |title=Box, stack and heap |url=https://doc.rust-lang.org/stable/rust-by-example/std/box.html |access-date=2022-06-13 |website=Rust by Example |archive-date=2022-05-31  |archive-url=https://web.archive.org/web/20220531114141/https://doc.rust-lang.org/stable/rust-by-example/std/box.html |url-status=live }}</ref>\n\nThe built-in reference types using the <code>&</code> symbol do not involve run-time reference counting. The safety and validity of the underlying pointers is verified at compile time, preventing [[dangling pointers]] and other forms of [[undefined behavior]].{{sfn|Klabnik|Nichols|2019|pp=70–75}} Rust's type system separates shared, [[Immutable object|immutable]] references of the form <code>&T</code> from unique, mutable references of the form <code>&mut T</code>. A mutable reference can be coerced to an immutable reference, but not vice versa.{{sfn|Klabnik|Nichols|2019|p=323}}\n\n=== Unsafe ===\n\nRust's memory safety checks may be circumvented through the use of {{rust|unsafe}} blocks. This allows programmers to dereference arbitrary raw pointers, call external code, or perform other low-level functionality not allowed by safe Rust.{{sfn|Klabnik|Nichols|2023|pp=420-429}} Some low-level functionality enabled in this way includes [[Volatile (computer programming)|volatile memory access]], architecture-specific intrinsics, [[type punning]], and inline assembly.{{sfn|McNamara|2021|p=139, 376–379, 395}}\n\nUnsafe code is sometimes needed to implement complex data structures.<ref name=\"UnsafeRustUse\">{{Cite journal |last1=Astrauskas |first1=Vytautas |last2=Matheja |first2=Christoph |last3=Poli |first3=Federico |last4=Müller |first4=Peter |last5=Summers |first5=Alexander J. |date=2020-11-13 |title=  How do programmers use unsafe rust?|url=https://dl.acm.org/doi/10.1145/3428204 |journal=  Proceedings of the ACM on Programming Languages|language=en |volume=4 |issue= |pages=1–27 |doi=10.1145/3428204 |issn=2475-1421|hdl=20.500.11850/465785 |hdl-access=free}}</ref> A frequently cited example is that it is difficult or impossible to implement [[doubly linked list]]s in safe Rust.<ref>{{Cite journal |last1=Lattuada |first1=Andrea |last2=Hance |first2=Travis |last3=Cho |first3=Chanhee |last4=Brun |first4=Matthias |last5=Subasinghe |first5=Isitha |last6=Zhou |first6=Yi |last7=Howell |first7=Jon |last8=Parno |first8=Bryan |last9=Hawblitzel |first9=Chris |date=2023-04-06 |title= Verus: Verifying Rust Programs using Linear Ghost Types|url=https://dl.acm.org/doi/10.1145/3586037 |journal= Proceedings of the ACM on Programming Languages|volume=7 |issue= |pages=85:286–85:315 |doi=10.1145/3586037|hdl=20.500.11850/610518 |hdl-access=free }}</ref><ref>{{Cite book |last1=Milano |first1=Mae |last2=Turcotti |first2=Julia |last3=Myers |first3=Andrew C. |chapter=A flexible type system for fearless concurrency |date=2022-06-09 |title=Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation |series= |location=New York, NY, USA |publisher=Association for Computing Machinery |pages=458–473 |doi=10.1145/3519939.3523443 |isbn=978-1-4503-9265-5|doi-access=free }}</ref><ref>{{Cite web |title=Introduction - Learning Rust With Entirely Too Many Linked Lists |url=https://rust-unofficial.github.io/too-many-lists/ |access-date=2025-08-06 |website=rust-unofficial.github.io}}</ref><ref>{{Cite book |last1=Noble |first1=James |last2=Mackay |first2=Julian |last3=Wrigstad |first3=Tobias |chapter=Rusty Links in Local Chains✱ |date=2023-10-16 |title=Proceedings of the 24th ACM International Workshop on Formal Techniques for Java-like Programs |chapter-url=https://doi.org/10.1145/3611096.3611097 |series= |location=New York, NY, USA |publisher=Association for Computing Machinery |pages=1–3 |doi=10.1145/3611096.3611097 |isbn=979-8-4007-0784-1|chapter-url-access=subscription }}</ref>\n\nProgrammers using unsafe Rust are considered responsible for upholding Rust's memory and type safety requirements, for example, that no two mutable references exist pointing to the same location.<ref name=IsRustSafely>{{Cite book |last1=Evans |first1=Ana Nora |last2=Campbell |first2=Bradford |last3=Soffa |first3=Mary Lou |chapter=Is rust used safely by software developers? |date=2020-10-01 |title=Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering |chapter-url=https://doi.org/10.1145/3377811.3380413 |series= |location=New York, NY, USA |publisher=Association for Computing Machinery |pages=246–257 |doi=10.1145/3377811.3380413 |isbn=978-1-4503-7121-6|arxiv=2007.00752 }}</ref> If programmers write code which violates these requirements, this results in [[undefined behavior]].<ref name=IsRustSafely/> The Rust documentation includes a list of behavior considered undefined, including accessing dangling or misaligned pointers, or breaking the aliasing rules for references.<ref>{{Cite web |title=Behavior considered undefined |url=https://doc.rust-lang.org/reference/behavior-considered-undefined.html |access-date=2025-08-06 |website=The Rust Reference}}</ref>\n<!--\n\n=== Closures ===\n\n-->\n\n=== Macros ===\nMacros allow generation and transformation of Rust code to reduce repetition. Macros come in two forms, with ''declarative macros'' defined through <code>macro_rules!</code>, and ''procedural macros'', which are defined in separate crates.{{sfn|Klabnik|Nichols|2023|pp=449–455}}{{sfn|Gjengset|2021|pp=101-102}}\n\n==== Declarative macros ====\nA declarative macro (also called a \"macro by example\") is a macro, defined using the <code>macro_rules!</code> keyword, that uses pattern matching to determine its expansion.<ref name=\"Rust Ref. – Macros By Example\">{{cite web |title=Macros By Example |url=https://doc.rust-lang.org/reference/macros-by-example.html |website=The Rust Reference |access-date=21 April 2023 |archive-date=2023-04-21  |archive-url=https://web.archive.org/web/20230421052332/https://doc.rust-lang.org/reference/macros-by-example.html |url-status=live }}</ref>{{sfn|Klabnik|Nichols|2019|pp=446–448}} Below is an example that sums over all its arguments:\n\n<syntaxhighlight lang=\"rust\">\nmacro_rules! sum {\n    ( $initial:expr $(, $expr:expr )* $(,)? ) => {\n        $initial $(+ $expr)*\n    }\n}\n\nfn main() {\n    let x = sum!(1, 2, 3);\n    println!(\"{x}\"); // prints 6\n}\n</syntaxhighlight>\n<!-- TODO explain -->\n==== Procedural macros ====\nProcedural macros are Rust functions that run and modify the compiler's input [[Token (parser)|token]] stream, before any other components are compiled. They are generally more flexible than declarative macros, but are more difficult to maintain due to their complexity.<ref name=\"rust-procedural-macros\">{{cite web |url=https://doc.rust-lang.org/reference/procedural-macros.html |title=Procedural Macros |website=The Rust Programming Language Reference |access-date=23 Mar 2021 |archive-date=7 November 2020 |archive-url=https://web.archive.org/web/20201107233444/https://doc.rust-lang.org/reference/procedural-macros.html |url-status=live}}</ref>{{sfn|Klabnik|Nichols|2019|pp=449–455}}\n\nProcedural macros come in three flavors:\n* Function-like macros <code>custom!(...)</code>\n* Derive macros <code>#[derive(CustomDerive)]</code>\n* Attribute macros <code>#[custom_attribute]</code>\n<!-- TODO example -->\n\n=== Interface with C and C++ ===\n\nRust supports the creation of [[foreign function interface]]s (FFI) through the {{rust|extern}} keyword. A function that uses the C [[calling convention]] can be written using {{rust|extern \"C\" fn}}. Symbols can be exported from Rust to other languages through the {{rust|#[no_mangle]}} attribute, and symbols can be imported into Rust through {{rust|extern}} blocks:{{refn|group=note|wrapping {{code|no_mangle}} with {{rust|unsafe}} as well as prefacing the {{rust|extern \"C\"}} block with {{rust|unsafe}} are required in the 2024 edition or later.<ref>{{Cite web |last=Baumgartner |first=Stefan |date=2025-05-23 |title=Programming language: Rust 2024 is the most comprehensive edition to date |url=https://www.heise.de/en/background/Programming-language-Rust-2024-is-the-most-comprehensive-edition-to-date-10393917.html |access-date=2025-06-28 |website=[[heise online]] |language=en}}</ref>}}{{sfn|Gjengset|2021|pp=193-209}}\n\n<syntaxhighlight lang=\"rust\">\n#[no_mangle]\npub extern \"C\" fn exported_from_rust(x: i32) -> i32 { x + 1 }\nunsafe extern \"C\" {\n    fn imported_into_rust(x: i32) -> i32;\n}\n</syntaxhighlight>\n\nThe {{rust|#[repr(C)]}} attribute enables deterministic memory layouts for {{rust|struct}}s and {{rust|enum}}s for use across FFI boundaries.{{sfn|Gjengset|2021|pp=193-209}} External libraries such as {{rust|bindgen}} and {{rust|cxx}} can generate Rust bindings for C/C++.{{sfn|Gjengset|2021|pp=193-209}}<ref>{{Cite web|title=Safe Interoperability between Rust and C++ with CXX|url=https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|date=2020-12-06|access-date=2021-01-03|website=InfoQ|language=en|archive-date=January 22, 2021|archive-url=https://web.archive.org/web/20210122142035/https://www.infoq.com/news/2020/12/cpp-rust-interop-cxx/|url-status=live}}</ref>\n\n== Ecosystem ==\n[[File:Cargo compiling.webm|thumb|right|Compiling a Rust program with Cargo]]\n\nThe Rust ecosystem includes its compiler, its [[#Standard library|standard library]], and additional components for software development. Component installation is typically managed by {{code|rustup}}, a Rust [[toolchain]] installer developed by the Rust project.{{sfn|Blandy|Orendorff|Tindall|2021|pp=6-8}}\n<!-- Add Miri Compiler? -->\n\n=== Compiler ===\nThe Rust compiler, {{code|rustc}}, compiles Rust code into [[Executable|binaries]]. First, the compiler parses the source code into an [[Abstract syntax tree|AST]]. Next, this AST is lowered to [[Intermediate representation|IR]]. The compiler backend is then invoked as a subcomponent to apply [[Optimizing compiler|optimizations]] and translate the resulting IR into [[object code]]. Finally, a [[Linker (computing)|linker]] is used to combine the object(s) into a single executable image.<ref>{{cite web |title=Overview of the compiler |url=https://rustc-dev-guide.rust-lang.org/overview.html |website=Rust Compiler Development Guide |publisher=Rust project contributors |access-date=7 November 2024 |archive-date=2023-05-31  |archive-url=https://web.archive.org/web/20230531035222/https://rustc-dev-guide.rust-lang.org/overview.html |url-status=live }}</ref>\n\nrustc uses [[LLVM]] as its compiler backend by default, but it also supports using alternative backends such as [[GNU Compiler Collection|GCC]] and [[Cranelift]].<ref>{{cite web |title=Code Generation |url=https://rustc-dev-guide.rust-lang.org/backend/codegen.html |website=Rust Compiler Development Guide |publisher=Rust project contributors |access-date=3 March 2024}}</ref> The intention of those alternative backends is to increase platform coverage of Rust or to improve compilation times.<ref>{{cite web |title=rust-lang/rustc_codegen_gcc |url=https://github.com/rust-lang/rustc_codegen_gcc#Motivation |website=[[GitHub]] |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref><ref>{{cite web |title=rust-lang/rustc_codegen_cranelift |url=https://github.com/rust-lang/rustc_codegen_cranelift |website=[[GitHub]] |publisher=The Rust Programming Language |access-date=3 March 2024 |date=2 March 2024}}</ref>\n\n=== Cargo ===\n[[File:Crates.io website.png|thumb|right|Screenshot of crates.io in June 2022]]\n\nCargo is Rust's [[Build system (software development)|build system]] and [[package manager]]. It downloads, compiles, distributes, and uploads packages—called ''crates''—that are maintained in an official registry. It also acts as a front-end for Clippy and other Rust components.<ref name=\"Nature\">{{Cite journal |last=Perkel |first=Jeffrey M. |date=2020-12-01 |title=Why scientists are turning to Rust |url=https://www.nature.com/articles/d41586-020-03382-2 |journal=[[Nature (journal)|Nature]] |language=en |volume=588 |issue=7836 |pages=185–186 |doi=10.1038/d41586-020-03382-2 |pmid=33262490 |bibcode=2020Natur.588..185P |s2cid=227251258 |access-date=May 15, 2022 |archive-date=May 6, 2022 |archive-url=https://web.archive.org/web/20220506040523/https://www.nature.com/articles/d41586-020-03382-2 |url-status=live|url-access=subscription }}</ref>\n\nBy default, Cargo sources its dependencies from the user-contributed registry ''crates.io'', but [[Git]] repositories, crates in the local filesystem, and other external sources can also be specified as dependencies.<ref>{{Cite web |last=Simone |first=Sergio De |date=2019-04-18 |title=Rust 1.34 Introduces Alternative Registries for Non-Public Crates |url=https://www.infoq.com/news/2019/04/rust-1.34-additional-registries |access-date=2022-07-14 |website=InfoQ |language=en |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714164454/https://www.infoq.com/news/2019/04/rust-1.34-additional-registries |url-status=live }}</ref>\n\n=== Rustfmt ===\nRustfmt is a [[code formatter]] for Rust. It formats whitespace and [[Indentation style|indentation]] to produce code in accordance with a common [[Programming style|style]], unless otherwise specified. It can be invoked as a standalone program, or from a Rust project through Cargo.{{sfn|Klabnik|Nichols|2019|pp=511–512}}\n\n=== Clippy ===\n[[File:Cargo clippy hello world example.png|thumb|right|Example output of Clippy on a hello world Rust program]]\nClippy is Rust's built-in [[linting]] tool to improve the correctness, performance, and readability of Rust code. {{as of|2025}}, it has 795 rules.<ref>{{Cite web |title=Clippy |date=2023-11-30 |url=https://rust-lang.github.io/rust-clippy/master/index.html |access-date=2025-10-09 |website=[[GitHub]] |publisher=The Rust Programming Language |archive-date=2021-05-23  |archive-url=https://web.archive.org/web/20210523042004/https://github.com/rust-lang/rust-clippy |url-status=live }}</ref><ref>{{Cite web |title=Clippy Lints |url=https://rust-lang.github.io/rust-clippy/master/index.html |access-date=2023-11-30 |website=The Rust Programming Language}}</ref>\n\n=== Versioning system ===\nFollowing Rust 1.0, new features are developed in ''nightly'' versions which are released daily. During each six-week release cycle, changes to nightly versions are released to beta, while changes from the previous beta version are released to a new stable version.<ref name=\"Rust Book G\">{{harvnb|Klabnik|Nichols|2019|loc=Appendix G – How Rust is Made and \"Nightly Rust\"}}</ref>\n\nEvery two or three years, a new \"edition\" is produced. Editions are released to allow making limited [[breaking changes]], such as promoting {{rust|await}} to a keyword to support [[async/await]] features. Crates targeting different editions can interoperate with each other, so a crate can upgrade to a new edition even if its callers or its dependencies still target older editions. Migration to a new edition can be assisted with automated tooling.{{sfn|Blandy|Orendorff|Tindall|2021|pp=176–177}}\n\n=== IDE support ===\n''rust-analyzer'' is a set of [[Utility software|utilities]] that provides [[integrated development environment]]s (IDEs) and [[text editor]]s with information about a Rust project through the [[Language Server Protocol]]. This enables features including [[autocomplete]], and [[compilation error]] display, while editing code.{{sfn|Klabnik|Nichols|2023|p=623}}\n\n== Performance ==\nSince it performs no garbage collection, Rust is often faster than other memory-safe languages.<ref>{{Cite web |last1=Anderson |first1=Tim |date=2021-11-30 |title=Can Rust save the planet? Why, and why not |url=https://www.theregister.com/2021/11/30/aws_reinvent_rust/ |access-date=2022-07-11 |website=[[The Register]] |language=en |url-status=live |archive-url=https://web.archive.org/web/20220711001629/https://www.theregister.com/2021/11/30/aws_reinvent_rust/ |archive-date=2022-07-11}}</ref><ref name=\"BeyondSafety\"/><ref>{{Cite web |last1=Yegulalp |first1=Serdar |date=2021-10-06 |title=What is the Rust language? Safe, fast, and easy software development |url=https://www.infoworld.com/article/3218074/what-is-rust-safe-fast-and-easy-software-development.html |access-date=2022-06-25 |website=[[InfoWorld]] |language=en |url-status=live |archive-url=https://web.archive.org/web/20220624101013/https://www.infoworld.com/article/3218074/what-is-rust-safe-fast-and-easy-software-development.html |archive-date=2022-06-24}}</ref> Most of Rust's memory safety guarantees impose no runtime overhead,{{sfn|McNamara|2021|p=11}} with the exception of [[Array (data structure)|array indexing]] which is checked at runtime by default.<ref name=SaferAtAnySpeed>{{Cite journal |last1=Popescu |first1=Natalie |last2=Xu |first2=Ziyang |last3=Apostolakis |first3=Sotiris |last4=August |first4=David I. |last5=Levy |first5=Amit |date=2021-10-15 |title=Safer at any speed: automatic context-aware safety enhancement for Rust |journal=Proceedings of the ACM on Programming Languages |volume=5 |issue=OOPSLA |quote=\"We observe a large variance in the overheads of checked indexing: 23.6% of benchmarks do report significant performance hits from checked indexing, but 64.5% report little-to-no impact and, surprisingly, 11.8% report improved performance ... Ultimately, while unchecked indexing can improve performance, most of the time it does not.\" |quote-page=5 |at=Section 2 |doi=10.1145/3485480 |s2cid=238212612|doi-access=free}}</ref>  The performance impact of array indexing bounds checks varies, but can be significant in some cases.<ref name=SaferAtAnySpeed/>\n\nMany of Rust's features are so-called ''zero-cost abstractions'', meaning they are optimized away at compile time and incur no runtime penalty.{{sfn|McNamara|2021|p=19, 27}} The ownership and borrowing system permits [[zero-copy]] implementations for some performance-sensitive tasks, such as [[parsing]].<ref>{{Cite book |last=Couprie |first=Geoffroy |title=2015 IEEE Security and Privacy Workshops |chapter=Nom, A Byte oriented, streaming, Zero copy, Parser Combinators Library in Rust |date=2015 |pages=142–148 |doi=10.1109/SPW.2015.31 |isbn=978-1-4799-9933-0 |s2cid=16608844 }}</ref> [[Static dispatch]] is used by default to eliminate [[method call]]s, except for methods called on dynamic trait objects.{{sfn|McNamara|2021|p=20}} The compiler also uses [[inline expansion]] to eliminate [[function call]]s and statically-dispatched method invocations.<ref>{{Cite web |title=Code generation |url=https://doc.rust-lang.org/reference/attributes/codegen.html |access-date=2022-10-09 |website=The Rust Reference |archive-date=2022-10-09 |archive-url=https://web.archive.org/web/20221009202615/https://doc.rust-lang.org/reference/attributes/codegen.html |url-status=live}}</ref>\n\nSince Rust uses [[LLVM]], all performance improvements in LLVM apply to Rust also.<ref name=\"how-fast-is-rust\">{{cite web |url=https://doc.rust-lang.org/1.0.0/complement-lang-faq.html#how-fast-is-rust? |title=How Fast Is Rust? |website=The Rust Programming Language FAQ |access-date=11 April 2019 |archive-date=28 October 2020 |archive-url=https://web.archive.org/web/20201028102013/https://doc.rust-lang.org/1.0.0/complement-lang-faq.html#how-fast-is-rust? |url-status=live}}</ref> Unlike C and C++, Rust allows the compiler to reorder struct and enum elements unless a <code>#[repr(C)]</code> representation attribute is applied.<ref>{{Cite book |last1=Farshin |first1=Alireza |last2=Barbette |first2=Tom |last3=Roozbeh |first3=Amir |last4=Maguire |first4=Gerald Q. Jr |last5=Kostić |first5=Dejan |year=2021 |url=https://dlnext.acm.org/doi/abs/10.1145/3445814.3446724 |access-date=2022-07-12 |language=en |doi=10.1145/3445814.3446724|title=Proceedings of the 26th ACM International Conference on Architectural Support for Programming Languages and Operating Systems |chapter=PacketMill: Toward per-Core 100-GBPS networking |pages=1–17 |isbn=9781450383172 |s2cid=231949599 |url-status=live |archive-url=https://web.archive.org/web/20220712060927/https://dlnext.acm.org/doi/abs/10.1145/3445814.3446724 |archive-date=2022-07-12 |quote=... While some compilers (e.g., Rust) support structure reordering [82], C & C++ compilers are forbidden to reorder data structures (e.g., struct or class) [74] ... }}</ref> This allows the compiler to optimize for memory footprint, alignment, and padding, which can be used to produce more efficient code in some cases.{{sfn|Gjengset|2021|p=22}}\n\n== Adoption ==\n{{See also|Category:Rust (programming language) software}}\n<!--\nIMPORTANT:\nPlease add entries only with independent published sources, e.g., news articles, not GitHub projects with no secondary source(s). For specific guidelines, see: Wikipedia:Identifying reliable sources\n-->\n\n[[File:Firefox logo, 2019.svg|thumb|right|150px|[[Firefox]] has components written in Rust as part of the underlying [[Gecko (software)|Gecko]] browser engine.]]\n\nRust is used in software across different domains. Components from the Servo browser engine (funded by [[Mozilla]] and [[Samsung]]) were incorporated in the [[Gecko (software)|Gecko]] browser engine underlying [[Firefox]].<ref>{{Cite web |last=Keizer |first=Gregg |date=2016-10-31 |title=Mozilla plans to rejuvenate Firefox in 2017 |url=https://www.computerworld.com/article/3137050/mozilla-plans-to-rejuvenate-firefox-in-2017.html |access-date=2023-05-13 |website=[[Computerworld]] |language=en |archive-date=2023-05-13  |archive-url=https://web.archive.org/web/20230513020437/https://www.computerworld.com/article/3137050/mozilla-plans-to-rejuvenate-firefox-in-2017.html |url-status=live }}</ref> In January 2023, Google ([[Alphabet Inc.|Alphabet]]) announced support for using third party Rust libraries in [[Chromium (web browser)|Chromium]].<ref>{{Cite web |last=Claburn |first=Thomas |date=2023-01-12 |title=Google polishes Chromium code with a layer of Rust |url=https://www.theregister.com/2023/01/12/google_chromium_rust/ |access-date=2024-07-17 |website=[[The Register]]}}</ref><ref>{{Cite web |last=Jansens |first=Dana |date=2023-01-12 |title=Supporting the Use of Rust in the Chromium Project |url=https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html |access-date=2023-11-12 |website=Google Online Security Blog |language=en |archive-date=2023-01-13  |archive-url=https://web.archive.org/web/20230113004438/https://security.googleblog.com/2023/01/supporting-use-of-rust-in-chromium.html |url-status=live }}</ref>\n\nRust is used in several [[Frontend and backend|backend]] software projects of large [[web service]]s. [[OpenDNS]], a [[Domain Name System|DNS]] resolution service owned by [[Cisco]], uses Rust internally.<ref>{{Cite web |last=Shankland |first=Stephen |date=2016-07-12 |title=Firefox will get overhaul in bid to get you interested again |url=https://www.cnet.com/tech/services-and-software/firefox-mozilla-gets-overhaul-in-a-bid-to-get-you-interested-again/ |access-date=2022-07-14 |publisher=[[CNET]] |language=en |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714172029/https://www.cnet.com/tech/services-and-software/firefox-mozilla-gets-overhaul-in-a-bid-to-get-you-interested-again/ |url-status=live }}</ref><ref>{{Cite web |author=Security Research Team |date=2013-10-04 |title=ZeroMQ: Helping us Block Malicious Domains in Real Time |url=https://umbrella.cisco.com/blog/zeromq-helping-us-block-malicious-domains |access-date=2023-05-13 |website=Cisco Umbrella |language=en-US |archive-date=2023-05-13  |archive-url=https://web.archive.org/web/20230513161542/https://umbrella.cisco.com/blog/zeromq-helping-us-block-malicious-domains |url-status=dead }}</ref> [[Amazon Web Services]] uses Rust in \"performance-sensitive components\" of its several services. In 2019, AWS [[open sourced|open-sourced]] [[Firecracker (software)|Firecracker]], a virtualization solution primarily written in Rust.<ref>{{Cite web |last=Cimpanu |first=Catalin |title=AWS to sponsor Rust project |url=https://www.zdnet.com/article/aws-to-sponsor-rust-project/ |date=2019-10-15 |access-date=2024-07-17 |website=[[ZDNET]] |language=en}}</ref> [[Microsoft Azure]] IoT Edge, a platform used to run Azure services on [[Internet of things|IoT]] devices, has components implemented in Rust.<ref>{{Cite web|url=https://www.theregister.co.uk/2018/06/27/microsofts_next_cloud_trick_kicking_things_out_of_the_cloud_to_azure_iot_edge/|title=Microsoft's next trick? Kicking things out of the cloud to Azure IoT Edge|last=Nichols|first=Shaun|date=27 June 2018|website=[[The Register]]|language=en|access-date=2019-09-27|archive-date=2019-09-27|archive-url=https://web.archive.org/web/20190927092433/https://www.theregister.co.uk/2018/06/27/microsofts_next_cloud_trick_kicking_things_out_of_the_cloud_to_azure_iot_edge/|url-status=live}}</ref> Microsoft also uses Rust to run containerized modules with [[WebAssembly]] and [[Kubernetes]].<ref>{{Cite web |last=Tung |first=Liam |date=2020-04-30 |title=Microsoft: Why we used programming language Rust over Go for WebAssembly on Kubernetes app |url=https://www.zdnet.com/article/microsoft-why-we-used-programming-language-rust-over-go-for-webassembly-on-kubernetes-app/ |access-date=2022-04-21 |website=[[ZDNET]] |language=en |archive-date=April 21, 2022 |archive-url=https://web.archive.org/web/20220421043549/https://www.zdnet.com/article/microsoft-why-we-used-programming-language-rust-over-go-for-webassembly-on-kubernetes-app/ |url-status=live}}</ref> [[Cloudflare]], a company providing [[content delivery network]] services, used Rust to build a new [[web proxy]] named Pingora for increased performance and efficiency.<ref>{{Cite web |last=Claburn |first=Thomas |date=20 September 2022 |title=In Rust We Trust: Microsoft Azure CTO shuns C and C++ |url=https://www.theregister.com/2022/09/20/rust_microsoft_c/ |access-date=7 July 2024 |website=[[The Register]]}}</ref> The [[npm|npm package manager]] used Rust for its production authentication service in 2019.<ref>{{Cite web |last=Simone |first=Sergio De |date=2019-03-10 |title=NPM Adopted Rust to Remove Performance Bottlenecks |url=https://www.infoq.com/news/2019/03/rust-npm-performance/ |access-date=2023-11-20 |website=InfoQ |language=en |archive-date=2023-11-19  |archive-url=https://web.archive.org/web/20231119135434/https://www.infoq.com/news/2019/03/rust-npm-performance/ |url-status=live }}</ref><ref>{{Cite book |last=Lyu |first=Shing |chapter=Welcome to the World of Rust |date=2020 |chapter-url=https://doi.org/10.1007/978-1-4842-5599-5_1 |title=Practical Rust Projects: Building Game, Physical Computing, and Machine Learning Applications |pages=1–8 |editor-last=Lyu |editor-first=Shing |access-date=2023-11-29 |place=Berkeley, CA |publisher=Apress |language=en |doi=10.1007/978-1-4842-5599-5_1 |isbn=978-1-4842-5599-5}}</ref><ref>{{Cite book |last=Lyu |first=Shing |chapter=Rust in the Web World |date=2021 |chapter-url=https://doi.org/10.1007/978-1-4842-6589-5_1 |title=Practical Rust Web Projects: Building Cloud and Web-Based Applications |pages=1–7 |editor-last=Lyu |editor-first=Shing |access-date=2023-11-29 |place=Berkeley, CA |publisher=Apress |language=en |doi=10.1007/978-1-4842-6589-5_1 |isbn=978-1-4842-6589-5}}</ref>\n\n[[File:Rust for Linux logo.svg|thumb|150px|The [[Rust for Linux]] project has been supported in the [[Linux kernel]] since 2022.]]\n\nIn operating systems, the [[Rust for Linux]] project, launched in 2020, merged initial support into the [[Linux kernel]] version 6.1 in late 2022.<ref name=UsenixRustForLinux>{{Cite web |last1=Li |first1=Hongyu |last2=Guo |first2=Liwei |last3=Yang |first3=Yexuan |last4=Wang |first4=Shangguang |last5=Xu |first5=Mengwei |date=2024-06-30 |title=An Empirical Study of Rust-for-Linux: The Success, Dissatisfaction, and Compromise |url=https://www.usenix.org/publications/loginonline/empirical-study-rust-linux-success-dissatisfaction-and-compromise |access-date=2024-11-28 |website=[[USENIX]] |language=en}}</ref><ref>{{Cite web |last=Corbet |first=Jonathan |date=2022-10-13 |title=A first look at Rust in the 6.1 kernel |url=https://lwn.net/Articles/910762/ |access-date=2023-11-11 |website=[[LWN.net]] |archive-date=2023-11-17 |archive-url=https://web.archive.org/web/20231117141103/https://lwn.net/Articles/910762/ |url-status=live }}</ref><ref>{{Cite news |last=Vaughan-Nichols |first=Steven |date=7 December 2021 |title=Rust takes a major step forward as Linux's second official language |url=https://www.zdnet.com/article/rust-takes-a-major-step-forward-as-linuxs-second-official-language/ |access-date=2024-11-27 |work=[[ZDNET]] |language=en}}</ref> The project is active with a team of 6–7 developers, and has added more Rust code with kernel releases from 2022 to 2024,<ref>{{Cite web |last=Corbet |first=Jonathan |date=2022-11-17 |title=Rust in the 6.2 kernel |url=https://lwn.net/Articles/914458/ |access-date=2024-11-28 |website=[[LWN.net]]}}</ref> aiming to demonstrate the [[Minimum viable product|minimum viability]] of the project and resolve key compatibility blockers.<ref name=UsenixRustForLinux/><ref>{{Cite web |last=Corbet |first=Jonathan |date=2024-09-24 |title=Committing to Rust in the kernel |url=https://lwn.net/Articles/991062/ |access-date=2024-11-28 |website=[[LWN.net]]}}</ref> The first drivers written in Rust were merged into the kernel for version 6.8.<ref name=UsenixRustForLinux/> The [[Android (operating system)|Android]] developers used Rust in 2021 to rewrite existing components.<ref>{{Cite web |last=Amadeo |first=Ron |date=2021-04-07 |title=Google is now writing low-level Android code in Rust |url=https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |access-date=2022-04-21 |website=Ars Technica |language=en-us |archive-date=April 8, 2021 |archive-url=https://web.archive.org/web/20210408001446/https://arstechnica.com/gadgets/2021/04/google-is-now-writing-low-level-android-code-in-rust/ |url-status=live}}</ref><ref>{{cite web |author1=Darkcrizt |title=Google Develops New Bluetooth Stack for Android, Written in Rust |url=https://blog.desdelinux.net/en/google-develops-a-new-bluetooth-stack-for-android-written-in-rust/ |website=Desde Linux |date=April 2, 2021 |access-date=31 August 2024 |archive-url=https://web.archive.org/web/20210825165930/https://blog.desdelinux.net/en/google-develops-a-new-bluetooth-stack-for-android-written-in-rust/ |archive-date=25 August 2021}}</ref> [[Microsoft]] has rewritten parts of [[Windows]] in Rust.<ref>{{Cite web |last=Claburn |first=Thomas |title=Microsoft is rewriting core Windows libraries in Rust |url=https://www.theregister.com/2023/04/27/microsoft_windows_rust/ |date=2023-04-27 |access-date=2023-05-13 |website=[[The Register]] |language=en |archive-date=2023-05-13  |archive-url=https://web.archive.org/web/20230513082735/https://www.theregister.com/2023/04/27/microsoft_windows_rust/ |url-status=live }}</ref> The r9 project aims to re-implement [[Plan 9 from Bell Labs]] in Rust.<ref>{{cite web |last1=Proven |first1=Liam |date=1 December 2023 |title=Small but mighty, 9Front's 'Humanbiologics' is here for the truly curious |url=https://www.theregister.com/2023/12/01/9front_humanbiologics/ |website=[[The Register]] |access-date=7 March 2024}}</ref> Rust has been used in the development of new operating systems such as [[Redox (operating system)|Redox]], a \"Unix-like\" operating system and [[microkernel]],<ref>{{cite news |last=Yegulalp |first=Serdar |date=21 March 2016 |title=Rust's Redox OS could show Linux a few new tricks |url=http://www.infoworld.com/article/3046100/open-source-tools/rusts-redox-os-could-show-linux-a-few-new-tricks.html |access-date=21 March 2016 |work=[[InfoWorld]] |archive-date=21 March 2016 |archive-url=https://web.archive.org/web/20160321192838/http://www.infoworld.com/article/3046100/open-source-tools/rusts-redox-os-could-show-linux-a-few-new-tricks.html |url-status=dead}}</ref> Theseus, an experimental operating system with modular state management,<ref>{{Cite web |first=Tim |last=Anderson |date=2021-01-14 |title=Another Rust-y OS: Theseus joins Redox in pursuit of safer, more resilient systems |url=https://www.theregister.com/2021/01/14/rust_os_theseus/ |access-date=2022-07-14 |website=[[The Register]] |language=en |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714112619/https://www.theregister.com/2021/01/14/rust_os_theseus/ |url-status=live }}</ref><ref>{{Cite book |last1=Boos |first1=Kevin |last2=Liyanage |first2=Namitha |last3=Ijaz |first3=Ramla |last4=Zhong |first4=Lin |date=2020 |title=Theseus: an Experiment in Operating System Structure and State Management |url=https://www.usenix.org/conference/osdi20/presentation/boos |language=en |pages=1–19 |isbn=978-1-939133-19-9 |archive-date=2023-05-13  |access-date=2023-05-13  |archive-url=https://web.archive.org/web/20230513164135/https://www.usenix.org/conference/osdi20/presentation/boos |url-status=live }}</ref> and most of [[Fuchsia (operating system)|Fuchsia]].<ref name=\"rustmag-1\">{{cite web |first1=HanDong |last1=Zhang |title=2022 Review {{!}} The adoption of Rust in Business |url=https://rustmagazine.org/issue-1/2022-review-the-adoption-of-rust-in-business/ |date=2023-01-31 |website=Rust Magazine |access-date=February 7, 2023 |language=en}}</ref> Rust is also used for command-line tools and operating system components, including [[Stratis (configuration daemon)|stratisd]], a [[file system]] manager<ref>{{cite web |url=https://www.marksei.com/fedora-29-new-features-startis/ |title=Fedora 29 new features: Startis now officially in Fedora |last=Sei |first=Mark |date=10 October 2018 |website=Marksei, Weekly sysadmin pills |access-date=2019-05-13 |archive-date=2019-04-13 |archive-url=https://web.archive.org/web/20190413075055/https://www.marksei.com/fedora-29-new-features-startis/ |url-status=live}}</ref><ref>{{Cite web |last=Proven |first=Liam |date=2022-07-12 |title=Oracle Linux 9 released, with some interesting additions |url=https://www.theregister.com/2022/07/12/oracle_linux_9/ |access-date=2022-07-14 |website=[[The Register]] |language=en |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714073400/https://www.theregister.com/2022/07/12/oracle_linux_9/ |url-status=live }}</ref> and COSMIC, a [[desktop environment]] by [[System76]].<ref>{{Cite web |last=Proven |first=Liam |date=2023-02-02 |title=System76 teases features coming in homegrown Rust-based desktop COSMIC |url=https://www.theregister.com/2023/02/02/system76_cosmic_xfce_updates/ |access-date=2024-07-17 |website=[[The Register]] |language=en |archive-date=2024-07-17  |archive-url=https://web.archive.org/web/20240717145511/https://www.theregister.com/2023/02/02/system76_cosmic_xfce_updates/ |url-status=live }}</ref>\n\nIn web development, [[Deno (software)|Deno]], a secure runtime for [[JavaScript]] and [[TypeScript]], is built on top of [[V8 (JavaScript engine)|V8]] using Rust and Tokio.<ref>{{Cite web |first=Vivian |last=Hu |date=2020-06-12 |title=Deno Is Ready for Production |url=https://www.infoq.com/news/2020/06/deno-1-ready-production/ |access-date=2022-07-14 |website=InfoQ |language=en |archive-date=2020-07-01  |archive-url=https://web.archive.org/web/20200701105007/https://www.infoq.com/news/2020/06/deno-1-ready-production/ |url-status=live }}</ref> Other notable adoptions in this space include [[Ruffle (software)|Ruffle]], an open-source [[SWF]] emulator,<ref>{{Cite web|last=Abrams|first=Lawrence|date=2021-02-06|title=This Flash Player emulator lets you securely play your old games|url=https://www.bleepingcomputer.com/news/software/this-flash-player-emulator-lets-you-securely-play-your-old-games/|access-date=2021-12-25|website=[[Bleeping Computer]]|language=en-us|archive-date=2021-12-25 |archive-url=https://web.archive.org/web/20211225124131/https://www.bleepingcomputer.com/news/software/this-flash-player-emulator-lets-you-securely-play-your-old-games/|url-status=live}}</ref> and [[Polkadot (cryptocurrency)|Polkadot]], an open source [[blockchain]] and [[cryptocurrency]] platform.<ref>{{Cite web |last=Kharif |first=Olga |date=October 17, 2020 |title=Ethereum Blockchain Killer Goes By Unassuming Name of Polkadot |url=https://www.bloomberg.com/news/articles/2020-10-17/ethereum-blockchain-killer-goes-by-unassuming-name-of-polkadot |url-access=subscription |access-date=July 14, 2021 |website=[[Bloomberg News]] |publisher=[[Bloomberg L.P.]] |archive-date=2020-10-17 |archive-url=https://web.archive.org/web/20201017192915/https://www.bloomberg.com/news/articles/2020-10-17/ethereum-blockchain-killer-goes-by-unassuming-name-of-polkadot |url-status=live }}</ref>\n\n[[Discord]], an [[instant messaging]] software company, rewrote parts of its system in Rust for increased performance in 2020. In the same year, Dropbox announced that its [[file synchronization]] had been rewritten in Rust. [[Facebook]] ([[Meta Platforms|Meta]]) used Rust to redesign its system that manages source code for internal projects.<ref name=\"MITTechReview\" />\n\nIn the 2025 [[Stack Overflow]] Developer Survey, 14.8% of respondents had recently done extensive development in Rust.<ref name=\"SO-2025-survey\">{{Cite web |title=2025 Stack Overflow Developer Survey – Technology |url=https://survey.stackoverflow.co/2025/technology |access-date=2025-08-09 |website=[[Stack Overflow]]}}</ref> The survey named Rust the \"most admired programming language\" annually from 2016 to 2025 (inclusive), as measured by the number of existing developers interested in continuing to work in the language.<ref>{{Cite web |last=Claburn |first=Thomas |date=2022-06-23 |title=Linus Torvalds says Rust is coming to the Linux kernel |url=https://www.theregister.com/2022/06/23/linus_torvalds_rust_linux_kernel/ |access-date=2022-07-15 |website=[[The Register]] |language=en |archive-date=2022-07-28 |archive-url=https://web.archive.org/web/20220728221531/https://www.theregister.com/2022/06/23/linus_torvalds_rust_linux_kernel/ |url-status=live }}</ref>{{refn|group=note|That is, among respondents who have done \"extensive development work [with Rust] in over the past year\" (14.8%), Rust had the largest percentage who also expressed interest to \"work in [Rust] over the next year\" (72.4%).<ref name=\"SO-2025-survey\"/>}} In 2025, 29.2% of developers not currently working in Rust expressed an interest in doing so.<ref name=\"SO-2025-survey\" />\n\n[[DARPA]] has a project TRACTOR (Translating All C to Rust) automatically translating C to Rust using techniques such as static analysis, dynamic analysis, and large language models.<ref>{{cite web |last1=Wallach |first1=Dan |title=TRACTOR: Translating All C to Rust |url=https://www.darpa.mil/research/programs/translating-all-c-to-rust |publisher=[[DARPA]] |access-date=3 August 2025}}</ref>\n\n== In academic research ==\n\nRust's safety and performance have been investigated in [[programming language theory]] research.<ref>{{Cite journal |last1=Jung |first1=Ralf |last2=Jourdan |first2=Jacques-Henri |last3=Krebbers |first3=Robbert |last4=Dreyer |first4=Derek |date=2017-12-27 |title=RustBelt: securing the foundations of the Rust programming language |url=https://dl.acm.org/doi/10.1145/3158154 |journal=Proceedings of the ACM on Programming Languages |language=en |volume=2 |issue=POPL |pages=1–34 |doi=10.1145/3158154 |issn=2475-1421|hdl=21.11116/0000-0003-34C6-3 |hdl-access=free }}</ref><ref name=\"UnsafeRustUse\"/><ref>{{Cite journal |last1=Popescu |first1=Natalie |last2=Xu |first2=Ziyang |last3=Apostolakis |first3=Sotiris |last4=August |first4=David I. |last5=Levy |first5=Amit |date=2021-10-20 |title=Safer at any speed: automatic context-aware safety enhancement for Rust |journal=Proceedings of the ACM on Programming Languages |language=en |volume=5 |issue=OOPSLA |pages=1–23 |doi=10.1145/3485480 |issn=2475-1421|doi-access=free }}</ref>\n\nRust's applicability to writing research software has been examined in other fields. A journal article published to ''[[Proceedings of the International Astronomical Union]]'' used Rust to simulate multi-planet systems.<ref name=ResearchSoftware1>{{Cite journal |last1=Blanco-Cuaresma |first1=Sergi |last2=Bolmont |first2=Emeline |date=2017-05-30 |title=What can the programming language Rust do for astrophysics? |url=https://www.cambridge.org/core/journals/proceedings-of-the-international-astronomical-union/article/what-can-the-programming-language-rust-do-for-astrophysics/B51B6DF72B7641F2352C05A502F3D881 |journal=[[Proceedings of the International Astronomical Union]] |language=en |volume=12 |issue=S325 |pages=341–344 |doi=10.1017/S1743921316013168 |arxiv=1702.02951 |bibcode=2017IAUS..325..341B |s2cid=7857871 |issn=1743-9213 |archive-date=2022-06-25  |access-date=2022-06-25  |archive-url=https://web.archive.org/web/20220625140128/https://www.cambridge.org/core/journals/proceedings-of-the-international-astronomical-union/article/what-can-the-programming-language-rust-do-for-astrophysics/B51B6DF72B7641F2352C05A502F3D881 |url-status=live }}</ref> An article published in ''[[Nature (journal)|Nature]]'' shared stories of bioinformaticians using Rust.<ref name=\"Nature\"/> Both articles found that Rust has advantages for its performance and safety, but cited the [[learning curve]] as being a primary drawback to its adoption.\n\n== Community ==\n[[File:Rustacean-orig-noshadow.svg|alt=A bright orange crab icon|thumb|Some Rust users refer to themselves as Rustaceans (similar to the word [[crustacean]]) and have adopted an orange crab, Ferris, as their unofficial mascot.{{sfn|Klabnik|Nichols|2019|p=4}}<ref>{{cite web |title=Getting Started |url=https://www.rust-lang.org/learn/get-started#ferris |website=The Rust Programming Language |access-date=11 October 2020 |archive-date=1 November 2020 |archive-url=https://web.archive.org/web/20201101145703/https://www.rust-lang.org/learn/get-started#ferris |url-status=live}}</ref>]]\n\nAccording to the ''[[MIT Technology Review]]'', the Rust community has been seen as \"unusually friendly\" to newcomers and particularly attracted people from the [[queer community]], partly due to its [[code of conduct]] which outlined a set of expectations for Rust community members to follow.<ref name=\"MITTechReview\"/> Inclusiveness of the community has been cited as an important factor for some Rust developers.<ref name=\"Nature\"/> The official Rust blog collects and publishes demographic data each year.<ref name=StateOfRustSurvey2024>{{Cite web |author=The Rust Survey Team |title=2024 State of Rust Survey Results |website=The Rust Programming Language |date=2025-02-13 |url=https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results.html |access-date=2025-09-07}}</ref>\n\n=== Rust Foundation ===\n{{Infobox organization\n| name = Rust Foundation\n| logo = Rust Foundation logo.png\n| formation = {{Start date and age|2021|02|08}}\n| founders = {{unbulleted list|[[Amazon Web Services]]|[[Google]]|[[Huawei]]|[[Microsoft]]|[[Mozilla Foundation]]}}\n| type = [[Nonprofit organization]]\n| location_country = [[United States]]\n| leader_title = [[Chairperson]]\n| leader_name = Shane Miller\n| leader_title2 = [[Executive Director]]\n| leader_name2 = Rebecca Rumbul\n| website = {{URL|foundation.rust-lang.org}}\n}}\n\nThe '''Rust Foundation''' is a [[Nonprofit organization|non-profit]] [[membership organization]] incorporated in [[United States]], with the primary purposes of backing the technical project as a [[legal entity]] and helping to manage the trademark and infrastructure assets.<ref>{{Cite web |first=Liam |last=Tung |date=2021-02-08 |title=The Rust programming language just took a huge step forwards |url=https://www.zdnet.com/article/the-rust-programming-language-just-took-a-huge-step-forwards/ |access-date=2022-07-14 |website=[[ZDNET]] |language=en |archive-date=2022-07-14  |archive-url=https://web.archive.org/web/20220714105527/https://www.zdnet.com/article/the-rust-programming-language-just-took-a-huge-step-forwards/ |url-status=live }}</ref><ref name=\":4\">{{Cite web |last=Vigliarolo |first=Brandon |date=2021-02-10 |title=The Rust programming language now has its own independent foundation |url=https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/ |archive-url=https://web.archive.org/web/20230320172900/https://www.techrepublic.com/article/the-rust-programming-language-now-has-its-own-independent-foundation/ |archive-date=2023-03-20 |access-date=2022-07-14 |website=[[TechRepublic]] |language=en-US}}</ref>\n\nIt was established on February 8, 2021, with five founding corporate members (Amazon Web Services, Huawei, Google, Microsoft, and Mozilla).<ref>{{cite news|first=Paul|last=Krill|date=9 February 2021|title=Rust language moves to independent foundation|url=https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|work=[[InfoWorld]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410161528/https://www.infoworld.com/article/3606774/rust-language-moves-to-independent-foundation.html|url-status=live}}</ref> The foundation's board is chaired by Shane Miller.<ref>{{cite news|first=Steven J.|last=Vaughan-Nichols|date=9 April 2021|title=AWS's Shane Miller to head the newly created Rust Foundation|url=https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|website=[[ZDNET]]|access-date=10 April 2021|archive-date=10 April 2021|archive-url=https://web.archive.org/web/20210410031305/https://www.zdnet.com/article/awss-shane-miller-to-head-the-newly-created-rust-foundation/|url-status=live}}</ref> Starting in late 2021, its Executive Director and CEO is Rebecca Rumbul.<!--Q109621019--><ref>{{Cite news|url=https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|title=Rust Foundation appoints Rebecca Rumbul as executive director|website=[[ZDNET]]|first=Steven J.|last=Vaughan-Nichols|date=17 November 2021|access-date=18 November 2021|archive-date=November 18, 2021|archive-url=https://web.archive.org/web/20211118062346/https://www.zdnet.com/article/rust-foundation-appoints-rebecca-rumbul-as-executive-director/|url-status=live}}</ref> Prior to this, Ashley Williams was interim executive director.<ref name=\":4\" />\n\n=== Governance teams ===\nThe Rust project is composed of ''teams'' that are responsible for different subareas of the development. The compiler team develops, manages, and optimizes compiler internals; and the language team designs new language features and helps implement them. The Rust project website lists 6 top-level teams {{as of|July 2024|lc=y}}.<ref>{{Cite web |title=Governance |url=https://www.rust-lang.org/governance |access-date=2024-07-18 |website=The Rust Programming Language |language=en-US |archive-date=May 10, 2022 |archive-url=https://web.archive.org/web/20220510225505/https://www.rust-lang.org/governance |url-status=live}}</ref> Representatives among teams form the Leadership council, which oversees the Rust project as a whole.<ref>{{Cite web |title=Introducing the Rust Leadership Council |url=https://blog.rust-lang.org/2023/06/20/introducing-leadership-council.html |date=2023-06-20 |access-date=2024-01-12 |website=Rust Blog |language=en}}</ref><!--<ref>{{Cite web |first=Tim |last=Anderson |date=2021-11-23 |title=Entire Rust moderation team resigns |url=https://www.theregister.com/2021/11/23/rust_moderation_team_quits/ |access-date=2024-01-12 |website=The Register |language=en}}</ref>-->\n\n== See also ==\n{{wikibooks|Rust for the Novice Programmer}}\n* [[Comparison of programming languages]]\n* [[History of programming languages]]\n* [[List of programming languages]]\n* [[List of programming languages by type]]\n* [[List of Rust software and tools]]\n* [[Outline of the Rust programming language]]\n\n== Notes ==\n{{Reflist|group=note}}\n\n== References ==\n=== Book sources ===\n{{refbegin}}\n* {{Cite book |last=Gjengset |first=Jon |title=Rust for Rustaceans |date=2021 |publisher=No Starch Press |isbn=9781718501850 |edition=1st |oclc=1277511986 |language=en}}\n* {{Cite book|last1=Klabnik|first1=Steve|url=https://books.google.com/books?id=0Vv6DwAAQBAJ|title=The Rust Programming Language (Covers Rust 2018)|last2=Nichols|first2=Carol|date=2019-08-12|publisher=No Starch Press|isbn=978-1-7185-0044-0|language=en}}\n* {{Cite book|last1=Blandy|first1=Jim|last2=Orendorff|first2=Jason|last3=Tindall|first3=Leonora F. S.|date=2021|edition=2nd|title=Programming Rust: Fast, Safe Systems Development|publisher=O'Reilly Media|isbn=978-1-4920-5254-8 |language=en|oclc=1289839504}}\n* {{Cite book|last1=McNamara|first1=Tim|title=Rust in Action|oclc=1153044639|date=2021|publisher=Manning Publications|isbn=978-1-6172-9455-6|language=en}}\n* {{Cite book |last1=Klabnik |first1=Steve |last2=Nichols |first2=Carol |title=The Rust programming language |date=2023 |publisher=No Starch Press |isbn=978-1-7185-0310-6 |edition=2nd |oclc=1363816350}}\n{{refend}}\n\n=== Others ===\n{{reflist|refs=\n<ref name=\"licenses\">{{cite web |url=https://www.rust-lang.org/policies/licenses |title=Licenses |access-date=2025-03-07 |website=The Rust Programming Language |archive-date=2025-02-23 |archive-url=https://web.archive.org/web/20250223193908/https://www.rust-lang.org/policies/licenses |url-status=live}}</ref>\n<ref name=\"influences\">{{cite web |title=Influences |url=https://doc.rust-lang.org/reference/influences.html |website=The Rust Reference |access-date=December 31, 2023 |archive-date=November 26, 2023 |archive-url=https://web.archive.org/web/20231126231034/https://doc.rust-lang.org/reference/influences.html |url-status=live}}</ref>\n<ref name=\"Jaloyan\">{{Cite arXiv|last=Jaloyan |first=Georges-Axel |date=19 October 2017 |title=Safe Pointers in SPARK 2014 |class=cs.PL |eprint=1710.07047}}</ref>\n<ref name=\"Lattner\">{{cite web |url=http://nondot.org/sabre/ |title=Chris Lattner's Homepage |last=Lattner |first=Chris |date=<!--Undated--> |website=Nondot |access-date=2019-05-14 |archive-date=2018-12-25 |archive-url=https://web.archive.org/web/20181225175312/http://nondot.org/sabre/ |url-status=live}}</ref>\n<ref name=\"Project Verona\">{{cite web|url=https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|title=Microsoft opens up Rust-inspired Project Verona programming language on GitHub|first=Liam|last=Tung|website=[[ZDNET]]|access-date=2020-01-17|archive-date=2020-01-17|archive-url=https://web.archive.org/web/20200117143852/https://www.zdnet.com/article/microsoft-opens-up-rust-inspired-project-verona-programming-language-on-github/|url-status=live}}</ref>\n}}\n\n== External links ==\n{{Sister project links|display=Rust |wikt=no |commons=Category:Rust (programming language) |b=no |n=no |q=no |s=no |v=Rust |voy=no |species=no |d=Q575650}}\n* {{Official website}}\n* {{GitHub|https://github.com/rust-lang/rust|Source code}}\n* [https://doc.rust-lang.org/stable/ Documentation]\n\n{{Rust (programming language)}}\n{{Programming languages}}\n{{Mozilla}}\n{{Authority control}}\n{{Portal bar|Computer programming}}\n\n[[Category:Rust (programming language)| ]]\n[[Category:Compiled programming languages]]\n[[Category:Concurrent programming languages]]\n[[Category:Free and open source compilers]]\n[[Category:Free software projects]]\n[[Category:Functional languages]]\n[[Category:High-level programming languages]]\n[[Category:Mozilla]]\n[[Category:Multi-paradigm programming languages]]\n[[Category:Pattern matching programming languages]]\n[[Category:Procedural programming languages]]\n[[Category:Programming languages created in 2015]]\n[[Category:Software using the Apache license]]\n[[Category:Software using the MIT license]]\n[[Category:Statically typed programming languages]]\n[[Category:Systems programming languages]]\n<!-- Hidden categories below -->\n[[Category:Articles with example Rust code]]"
}
